"""
–ü–∞—Ä—Å–µ—Ä –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ä–∞—Å—Ö–æ–¥–∞—Ö –∏ –¥–æ—Ö–æ–¥–∞—Ö –∏–∑ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
"""
import re
import logging
import asyncio
from typing import Optional, Dict, Any, Tuple
from decimal import Decimal, InvalidOperation
from datetime import datetime, date, time
from dateutil import parser as date_parser
from asgiref.sync import sync_to_async
from bot.utils.language import get_text

logger = logging.getLogger(__name__)

# –°–ª–æ–≤–∞—Ä—å –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ —á–∏—Å–µ–ª —Å–ª–æ–≤–∞–º–∏ –≤ —Ü–∏—Ñ—Ä—ã
WORD_TO_NUMBER = {
    # –ê–Ω–≥–ª–∏–π—Å–∫–∏–π
    'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5,
    'six': 6, 'seven': 7, 'eight': 8, 'nine': 9, 'ten': 10,
    'eleven': 11, 'twelve': 12, 'thirteen': 13, 'fourteen': 14, 'fifteen': 15,
    'sixteen': 16, 'seventeen': 17, 'eighteen': 18, 'nineteen': 19, 'twenty': 20,
    'thirty': 30, 'forty': 40, 'fifty': 50, 'sixty': 60, 'seventy': 70,
    'eighty': 80, 'ninety': 90, 'hundred': 100, 'thousand': 1000,
    # –†—É—Å—Å–∫–∏–π
    '–Ω–æ–ª—å': 0, '–æ–¥–∏–Ω': 1, '–æ–¥–Ω–∞': 1, '–¥–≤–∞': 2, '–¥–≤–µ': 2, '—Ç—Ä–∏': 3, '—á–µ—Ç—ã—Ä–µ': 4, '–ø—è—Ç—å': 5,
    '—à–µ—Å—Ç—å': 6, '—Å–µ–º—å': 7, '–≤–æ—Å–µ–º—å': 8, '–¥–µ–≤—è—Ç—å': 9, '–¥–µ—Å—è—Ç—å': 10,
    '–æ–¥–∏–Ω–Ω–∞–¥—Ü–∞—Ç—å': 11, '–¥–≤–µ–Ω–∞–¥—Ü–∞—Ç—å': 12, '—Ç—Ä–∏–Ω–∞–¥—Ü–∞—Ç—å': 13, '—á–µ—Ç—ã—Ä–Ω–∞–¥—Ü–∞—Ç—å': 14, '–ø—è—Ç–Ω–∞–¥—Ü–∞—Ç—å': 15,
    '—à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç—å': 16, '—Å–µ–º–Ω–∞–¥—Ü–∞—Ç—å': 17, '–≤–æ—Å–µ–º–Ω–∞–¥—Ü–∞—Ç—å': 18, '–¥–µ–≤—è—Ç–Ω–∞–¥—Ü–∞—Ç—å': 19, '–¥–≤–∞–¥—Ü–∞—Ç—å': 20,
    '—Ç—Ä–∏–¥—Ü–∞—Ç—å': 30, '—Å–æ—Ä–æ–∫': 40, '–ø—è—Ç—å–¥–µ—Å—è—Ç': 50, '—à–µ—Å—Ç—å–¥–µ—Å—è—Ç': 60, '—Å–µ–º—å–¥–µ—Å—è—Ç': 70,
    '–≤–æ—Å–µ–º—å–¥–µ—Å—è—Ç': 80, '–¥–µ–≤—è–Ω–æ—Å—Ç–æ': 90, '—Å—Ç–æ': 100, '—Ç—ã—Å—è—á–∞': 1000,
}

def convert_words_to_numbers(text: str) -> str:
    """
    –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —á–∏—Å–ª–∞ —Å–ª–æ–≤–∞–º–∏ –≤ —Ü–∏—Ñ—Ä—ã
    –ü—Ä–∏–º–µ—Ä—ã:
    - "Apple minus two" -> "Apple minus 2"
    - "–∫–æ—Ñ–µ —Ç—Ä–∏" -> "–∫–æ—Ñ–µ 3"
    - "twenty five" -> "25"
    - "–¥–≤–∞–¥—Ü–∞—Ç—å –ø—è—Ç—å" -> "25"
    """
    if not text:
        return text

    text_lower = text.lower()
    words = text_lower.split()
    result_words = []
    i = 0

    while i < len(words):
        word = words[i].strip('.,!?;:')

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å–ª–æ–≤–æ —á–∏—Å–ª–æ–º
        if word in WORD_TO_NUMBER:
            number = WORD_TO_NUMBER[word]

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ –¥–ª—è —Å–æ—Å—Ç–∞–≤–Ω—ã—Ö —á–∏—Å–µ–ª (twenty one -> 21)
            if i + 1 < len(words):
                next_word = words[i + 1].strip('.,!?;:')
                if next_word in WORD_TO_NUMBER:
                    next_number = WORD_TO_NUMBER[next_word]
                    # –ï—Å–ª–∏ —Å–ª–µ–¥—É—é—â–µ–µ —á–∏—Å–ª–æ –º–µ–Ω—å—à–µ 10 –∏ —Ç–µ–∫—É—â–µ–µ –∫—Ä–∞—Ç–Ω–æ 10
                    if next_number < 10 and number >= 10 and number < 100:
                        number += next_number
                        i += 1  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ

            result_words.append(str(number))
        else:
            result_words.append(words[i])

        i += 1

    return ' '.join(result_words)

# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è sync_to_async —Å Django ORM
def make_sync_to_async(func):
    """–°–æ–∑–¥–∞–µ—Ç –æ–±–µ—Ä—Ç–∫—É –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ"""
    return sync_to_async(func)

# –ü–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –¥–∞—Ç—ã
DATE_PATTERNS = [
    r'(\d{1,2})[.\/-](\d{1,2})[.\/-](\d{4})',  # –¥–¥.–º–º.–≥–≥–≥–≥ –∏–ª–∏ –¥–¥/–º–º/–≥–≥–≥–≥
    r'(\d{1,2})[.\/-](\d{1,2})[.\/-](\d{2})',    # –¥–¥.–º–º.–≥–≥ –∏–ª–∏ –¥–¥/–º–º/–≥–≥
]

# –ü–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Å—É–º–º—ã
AMOUNT_PATTERNS = [
    r'(\d+(?:[.,]\d+)?)\s*(?:—Ä—É–±|—Ä—É–±–ª–µ–π|—Ä|‚ÇΩ)',  # 100 —Ä—É–±, 100.50 —Ä
    r'(\d+(?:[.,]\d+)?)\s*(?:usd|\$|–¥–æ–ª–ª|–¥–æ–ª–ª–∞—Ä)',  # 100 USD, $100
    r'(\d+(?:[.,]\d+)?)\s*(?:eur|‚Ç¨|–µ–≤—Ä–æ)',  # 100 EUR, ‚Ç¨100
    r'(\d+(?:[.,]\d+)?)\s*(?:cny|¬•|—é–∞–Ω|—é–∞–Ω–µ–π)',  # 100 CNY
    # Latin American currencies
    r'(\d+(?:[.,]\d+)?)\s*(?:ars|–ø–µ—Å–æ|–∞—Ä–≥–µ–Ω—Ç–∏–Ω—Å–∫–∏—Ö?)',  # 100 ARS, Argentine Peso
    r'(\d+(?:[.,]\d+)?)\s*(?:cop|–∫–æ–ª—É–º–±–∏–π—Å–∫–∏—Ö?)',  # 100 COP, Colombian Peso
    r'(\d+(?:[.,]\d+)?)\s*(?:pen|—Å–æ–ª–µ–π?|–ø–µ—Ä—É–∞–Ω—Å–∫–∏—Ö?)',  # 100 PEN, Peruvian Sol
    r'(\d+(?:[.,]\d+)?)\s*(?:clp|—á–∏–ª–∏–π—Å–∫–∏—Ö?)',  # 100 CLP, Chilean Peso
    r'(\d+(?:[.,]\d+)?)\s*(?:mxn|–º–µ–∫—Å–∏–∫–∞–Ω—Å–∫–∏—Ö?)',  # 100 MXN, Mexican Peso
    r'(\d+(?:[.,]\d+)?)\s*(?:brl|—Ä–µ–∞–ª–æ–≤?|–±—Ä–∞–∑–∏–ª—å—Å–∫–∏—Ö?)',  # 100 BRL, Brazilian Real
    r'(\d+(?:[.,]\d+)?)\s*$',  # –ø—Ä–æ—Å—Ç–æ —á–∏—Å–ª–æ –≤ –∫–æ–Ω—Ü–µ
    r'^(\d+(?:[.,]\d+)?)\s',  # —á–∏—Å–ª–æ –≤ –Ω–∞—á–∞–ª–µ
    r'\s(\d+(?:[.,]\d+)?)\s',  # —á–∏—Å–ª–æ –≤ —Å–µ—Ä–µ–¥–∏–Ω–µ
]

# –ü–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≤–∞–ª—é—Ç—ã
CURRENCY_PATTERNS = {
    # Major world currencies
    'USD': [r'\$', r'\busd\b', r'\b–¥–æ–ª–ª', r'\b–¥–æ–ª–ª–∞—Ä', r'\bdollars?\b'],
    'EUR': [r'‚Ç¨', r'\beur\b', r'\b–µ–≤—Ä–æ', r'\beuro'],
    'GBP': [r'¬£', r'\bgbp\b', r'\b—Ñ—É–Ω—Ç', r'\bsterling', r'\bpounds?\b'],
    'CNY': [r'¬•', r'\bcny\b', r'\b—é–∞–Ω', r'\byuan', r'\brenminbi', r'\brmb\b'],
    'CHF': [r'\bchf\b', r'‚Ç£', r'\b—Ñ—Ä–∞–Ω–∫(?:–æ–≤|–∞)?\b', r'\bswiss\s+franc', r'\bfrancs?\b'],
    'INR': [r'\binr\b', r'‚Çπ', r'\b—Ä—É–ø–∏[–π—è–µ—é]', r'\b–∏–Ω–¥–∏–π—Å–∫.*—Ä—É–ø'],
    'TRY': [r'\btry\b', r'‚Ç∫', r'\b–ª–∏—Ä[–∞–∏—ã]?\b', r'\b—Ç—É—Ä–µ—Ü.*–ª–∏—Ä'],

    # Local currencies (CIS and nearby)
    'KZT': [r'\bkzt\b', r'‚Ç∏', r'\b—Ç–µ–Ω–≥–µ', r'\b—Ç–µ–Ω—å–≥–µ', r'\b—Ç–µ–Ω–≥[–µ–∏–∏—è]', r'\b—Ç–Ω–≥', r'\btenge'],
    'UAH': [r'\buah\b', r'\b–≥—Ä–Ω', r'\b–≥—Ä–∏–≤–Ω[–∞-—è]*', r'\b–≥—Ä–∏–≤–µ–Ω', r'\bhryvni?a', r'\bhryvnya'],
    'BYN': [r'\bbyn\b', r'\bbyr\b', r'\b–±–µ–ª[–∞–æ]—Ä—É—Å.*—Ä—É–±', r'\bbelarus.*rubl', r'\bbelarusian\s+ruble'],
    'RUB': [r'‚ÇΩ', r'\brub\b', r'\b—Ä—É–±', r'\b—Ä—É–±–ª'],
    'UZS': [r'\buzs\b', r"\bso['']m", r'\b—Å—É–º(?:–æ–≤|—ã|—É)?\b', r'\b—É–∑–±–µ–∫.*—Å—É–º', r'\buzbek.*som'],
    'AMD': [r'\bamd\b', r'\b–¥—Ä–∞–º', r'\bdram'],
    'TMT': [r'\btmt\b', r'\b—Ç—É—Ä–∫–º–µ–Ω.*–º–∞–Ω–∞—Ç', r'\bturkmen.*manat'],
    'AZN': [r'\bazn\b', r'\b–∞–∑–µ—Ä.*–º–∞–Ω–∞—Ç', r'\bazer.*manat', r'\b–º–∞–Ω–∞—Ç(?:–æ–≤|—ã)?\b'],
    'KGS': [r'\bkgs\b', r'\bkgz\b', r'\b—Å–æ–º(?:–æ–≤|—ã|—É)?\b', r'\b–∫–∏—Ä–≥–∏–∑.*—Å–æ–º', r'\b–∫—ã—Ä–≥.*—Å–æ–º'],
    'TJS': [r'\btjs\b', r'\b—Å–æ–º–æ–Ω[–∏—è]?\b', r'\b—Ç–∞–¥–∂–∏–∫.*—Å–æ–º', r'\btajik.*somoni'],
    'MDL': [r'\bmdl\b', r'\b–ª–µ–π(?:–µ–≤|—è|–∏|–µ–º|—è–º–∏)?\b', r'\b–º–æ–ª–¥–∞–≤.*–ª–µ–π', r'\bmoldov.*le[ui]'],
    'GEL': [r'\bgel\b', r'\b–ª–∞—Ä–∏\b', r'\blari\b', r'\bgruzi.*lari'],

    # Latin American currencies
    'ARS': [r'\bars\b', r'\b–∞—Ä–≥–µ–Ω—Ç–∏–Ω—Å–∫–∏—Ö?', r'\b–∞—Ä–≥–µ–Ω—Ç–∏–Ω—Å–∫–æ–µ', r'\b–∞—Ä–≥–µ–Ω—Ç–∏–Ω—Å–∫–∏–π', r'\bargentin[ea].*peso', r'\b–ø–µ—Å–æ'],
    'COP': [r'\bcop\b', r'\b–∫–æ–ª—É–º–±–∏–π—Å–∫–∏—Ö?', r'\b–∫–æ–ª—É–º–±–∏–π—Å–∫–æ–µ', r'\b–∫–æ–ª—É–º–±–∏–π—Å–∫–∏–π', r'\bcolombian.*peso'],
    'PEN': [r'\bpen\b', r'\b—Å–æ–ª–µ–π?', r'\b–ø–µ—Ä—É–∞–Ω—Å–∫–∏—Ö?', r'\b–ø–µ—Ä—É–∞–Ω—Å–∫–æ–µ', r'\b–ø–µ—Ä—É–∞–Ω—Å–∫–∏–π', r'\bperuvian\s+sol'],
    'CLP': [r'\bclp\b', r'\b—á–∏–ª–∏–π—Å–∫–∏—Ö?', r'\b—á–∏–ª–∏–π—Å–∫–æ–µ', r'\b—á–∏–ª–∏–π—Å–∫–∏–π', r'\bchilean.*peso'],
    'MXN': [r'\bmxn\b', r'\b–º–µ–∫—Å–∏–∫–∞–Ω—Å–∫–∏—Ö?', r'\b–º–µ–∫—Å–∏–∫–∞–Ω—Å–∫–æ–µ', r'\b–º–µ–∫—Å–∏–∫–∞–Ω—Å–∫–∏–π', r'\bmexican.*peso'],
    'BRL': [r'\bbrl\b', r'\b—Ä–µ–∞–ª(?:–æ–≤|—ã)?', r'\b–±—Ä–∞–∑–∏–ª—å—Å–∫–∏—Ö?', r'\b–±—Ä–∞–∑–∏–ª—å—Å–∫–æ–µ', r'\b–±—Ä–∞–∑–∏–ª—å—Å–∫–∏–π', r'\bbrazilian\s+real'],
}


# –ü–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–æ—Ö–æ–¥–∞ - –∑–Ω–∞–∫ + –∏–ª–∏ —Å–ª–æ–≤–æ "–ø–ª—é—Å"
INCOME_PATTERNS = [
    r'^\+',  # –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å +
    r'^\+\d',  # –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å + –∏ —Å—Ä–∞–∑—É —Ü–∏—Ñ—Ä–∞ (+35000)
    r'\s\+\d',  # –ü—Ä–æ–±–µ–ª, –∑–∞—Ç–µ–º + –∏ —Ü–∏—Ñ—Ä—ã (–¥–æ–ª–≥ +1200)
    r'\+\s*\d',  # + –∏ —Ü–∏—Ñ—Ä—ã —Å –≤–æ–∑–º–æ–∂–Ω—ã–º –ø—Ä–æ–±–µ–ª–æ–º
    r'^–ø–ª—é—Å\s+\d',  # –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å–æ —Å–ª–æ–≤–∞ "–ø–ª—é—Å" –∏ —Ü–∏—Ñ—Ä–∞ (–ø–ª—é—Å 5000)
    r'\s–ø–ª—é—Å\s+\d',  # –ü—Ä–æ–±–µ–ª, –∑–∞—Ç–µ–º "–ø–ª—é—Å" –∏ —Ü–∏—Ñ—Ä—ã (–∑–∞—Ä–ø–ª–∞—Ç–∞ –ø–ª—é—Å 1200)
    r'^–ø–ª—é—Å\s*\d',  # "–ø–ª—é—Å" –∏ —Ü–∏—Ñ—Ä—ã —Å –≤–æ–∑–º–æ–∂–Ω—ã–º –ø—Ä–æ–±–µ–ª–æ–º
    r'^plus\s+\d',  # –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å–æ —Å–ª–æ–≤–∞ "plus" –∏ —Ü–∏—Ñ—Ä–∞ (plus 5000)
    r'\splus\s+\d',  # –ü—Ä–æ–±–µ–ª, –∑–∞—Ç–µ–º "plus" –∏ —Ü–∏—Ñ—Ä—ã (bonus plus 1200)
    r'^plus\s*\d',  # "plus" –∏ —Ü–∏—Ñ—Ä—ã —Å –≤–æ–∑–º–æ–∂–Ω—ã–º –ø—Ä–æ–±–µ–ª–æ–º
]

# –ü–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è —è–≤–Ω–æ–≥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç—Ä–∞—Ç—ã - –∑–Ω–∞–∫ - –∏–ª–∏ —Å–ª–æ–≤–æ "–º–∏–Ω—É—Å"
EXPENSE_PATTERNS = [
    r'^\-',  # –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å -
    r'^\-\d',  # –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å - –∏ —Å—Ä–∞–∑—É —Ü–∏—Ñ—Ä–∞ (-500)
    r'\s\-\d',  # –ü—Ä–æ–±–µ–ª, –∑–∞—Ç–µ–º - –∏ —Ü–∏—Ñ—Ä—ã (–∫–æ—Ñ–µ -200)
    r'\-\s*\d',  # - –∏ —Ü–∏—Ñ—Ä—ã —Å –≤–æ–∑–º–æ–∂–Ω—ã–º –ø—Ä–æ–±–µ–ª–æ–º
    r'^–º–∏–Ω—É—Å\s+\d',  # –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å–æ —Å–ª–æ–≤–∞ "–º–∏–Ω—É—Å" –∏ —Ü–∏—Ñ—Ä–∞ (–º–∏–Ω—É—Å 5000)
    r'\s–º–∏–Ω—É—Å\s+\d',  # –ü—Ä–æ–±–µ–ª, –∑–∞—Ç–µ–º "–º–∏–Ω—É—Å" –∏ —Ü–∏—Ñ—Ä—ã (–∫–æ—Ñ–µ –º–∏–Ω—É—Å 200)
    r'^–º–∏–Ω—É—Å\s*\d',  # "–º–∏–Ω—É—Å" –∏ —Ü–∏—Ñ—Ä—ã —Å –≤–æ–∑–º–æ–∂–Ω—ã–º –ø—Ä–æ–±–µ–ª–æ–º
    r'^minus\s+\d',  # –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å–æ —Å–ª–æ–≤–∞ "minus" –∏ —Ü–∏—Ñ—Ä–∞ (minus 5000)
    r'\sminus\s+\d',  # –ü—Ä–æ–±–µ–ª, –∑–∞—Ç–µ–º "minus" –∏ —Ü–∏—Ñ—Ä—ã (coffee minus 200)
    r'^minus\s*\d',  # "minus" –∏ —Ü–∏—Ñ—Ä—ã —Å –≤–æ–∑–º–æ–∂–Ω—ã–º –ø—Ä–æ–±–µ–ª–æ–º
]

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Å–ª–æ–≤–∞—Ä—å –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤ –∏–∑ models
from expenses.models import CATEGORY_KEYWORDS as MODEL_CATEGORY_KEYWORDS

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º helper —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏
from bot.utils.category_helpers import get_category_display_name
from bot.utils.income_category_definitions import (
    DEFAULT_INCOME_CATEGORY_KEY,
    detect_income_category_key,
    get_income_category_display_name as get_income_category_display_for_key,
    get_income_type,
    normalize_income_category_key,
)

def extract_date_from_text(text: str) -> Tuple[Optional[date], str]:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç –¥–∞—Ç—É –∏–∑ —Ç–µ–∫—Å—Ç–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ—Ä—Ç–µ–∂ (–¥–∞—Ç–∞, —Ç–µ–∫—Å—Ç_–±–µ–∑_–¥–∞—Ç—ã)
    –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ç–æ–ª—å–∫–æ —á–∏—Å–ª–æ–≤—ã–µ –¥–∞—Ç—ã –≤ —Ñ–æ—Ä–º–∞—Ç–∞—Ö: –¥–¥.–º–º.–≥–≥–≥–≥ –∏–ª–∏ –¥–¥.–º–º.–≥–≥
    
    –ü—Ä–∏–º–µ—Ä—ã:
    - "–ö–æ—Ñ–µ 200 15.03.2024" -> (date(2024, 3, 15), "–ö–æ—Ñ–µ 200")
    - "25.12.2023 –ø–æ–¥–∞—Ä–∫–∏ 5000" -> (date(2023, 12, 25), "–ø–æ–¥–∞—Ä–∫–∏ 5000")
    - "–ü—Ä–æ–¥—É–∫—Ç—ã 1500" -> (None, "–ü—Ä–æ–¥—É–∫—Ç—ã 1500")
    """
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á–∏—Å–ª–æ–≤—ã–µ –¥–∞—Ç—ã
    for pattern in DATE_PATTERNS:
        match = re.search(pattern, text)
        if match:
            try:
                if len(match.groups()) == 3:
                    # –ü–æ–ª–Ω–∞—è –¥–∞—Ç–∞ –¥–¥.–º–º.–≥–≥–≥–≥ –∏–ª–∏ –¥–¥.–º–º.–≥–≥
                    day = int(match.group(1))
                    month = int(match.group(2))
                    year_str = match.group(3)
                    
                    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–≤—É–∑–Ω–∞—á–Ω–æ–≥–æ –≥–æ–¥–∞
                    if len(year_str) == 2:
                        year = 2000 + int(year_str)
                    else:
                        year = int(year_str)
                    
                    # –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞—Ç—ã
                    if 1 <= day <= 31 and 1 <= month <= 12:
                        expense_date = date(year, month, day)
                        
                        # –£–±–∏—Ä–∞–µ–º –¥–∞—Ç—É –∏–∑ —Ç–µ–∫—Å—Ç–∞
                        text_without_date = text[:match.start()] + text[match.end():]
                        text_without_date = ' '.join(text_without_date.split())  # –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
                        
                        return expense_date, text_without_date
                        
            except (ValueError, TypeError) as e:
                logger.debug(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ –¥–∞—Ç—ã –∏–∑ —Ç–µ–∫—Å—Ç–∞ '{text}': {e}")
                continue
    
    # –ï—Å–ª–∏ –¥–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º None –∏ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç
    return None, text


def extract_amount_from_patterns(text: str) -> Tuple[Optional[Decimal], Optional[str]]:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç —Å—É–º–º—É –∏–∑ —Ç–µ–∫—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É—è –Ω–∞–±–æ—Ä –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤, –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ—Ä—Ç–µ–∂
    (—Å—É–º–º–∞, —Ç–µ–∫—Å—Ç_–±–µ–∑_—Å—É–º–º—ã). –ï—Å–ª–∏ —Å—É–º–º—É –Ω–∞–π—Ç–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç (None, None).
    """
    if not text:
        return None, None

    for pattern in AMOUNT_PATTERNS:
        match = re.search(pattern, text, re.IGNORECASE)
        if not match:
            continue

        amount_str = match.group(1).replace(',', '.')
        try:
            amount = Decimal(amount_str)
        except (ValueError, InvalidOperation):
            logger.debug(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ —Å—É–º–º—ã '{amount_str}' —Å –ø–∞—Ç—Ç–µ—Ä–Ω–æ–º '{pattern}'")
            continue

        match_start = match.start()
        match_end = match.end()
        text_without_amount = (text[:match_start] + ' ' + text[match_end:]).strip()
        return amount, text_without_amount

    return None, None

# –°—Ç–∞—Ä—ã–π —Å–ª–æ–≤–∞—Ä—å –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
OLD_CATEGORY_KEYWORDS = {
    '–∞–∑—Å': [
        # –û—Å–Ω–æ–≤–Ω—ã–µ —Å–ª–æ–≤–∞
        '–∞–∑—Å', '–∑–∞–ø—Ä–∞–≤–∫–∞', '–±–µ–Ω–∑–∏–Ω', '–¥–∏–∑–µ–ª—å', '—Å–æ–ª—è—Ä–∫–∞', '—Ç–æ–ø–ª–∏–≤–æ', '–≥–æ—Ä—é—á–µ–µ',
        # –ë—Ä–µ–Ω–¥—ã –ê–ó–°
        '–ª—É–∫–æ–π–ª', '—Ä–æ—Å–Ω–µ—Ñ—Ç—å', '–≥–∞–∑–ø—Ä–æ–º–Ω–µ—Ñ—Ç—å', '–≥–∞–∑–ø—Ä–æ–º', 'shell', 'bp', 'esso', '—Ç–∞—Ç–Ω–µ—Ñ—Ç—å',
        # –¢–∏–ø—ã —Ç–æ–ø–ª–∏–≤–∞
        '95', '92', '98', '100', '–¥—Ç', '–∞–∏-95', '–∞–∏-92', '–∞–∏-98',
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ
        '–∫–æ–ª–æ–Ω–∫–∞', '–ª–∏—Ç—Ä', '–ª–∏—Ç—Ä–æ–≤', '–∑–∞–ª–∏–ª', '–∑–∞–ø—Ä–∞–≤–∏–ª—Å—è', '–∑–∞–ø—Ä–∞–≤–∏–ª–∞—Å—å'
    ],
    '—Å—É–ø–µ—Ä–º–∞—Ä–∫–µ—Ç—ã': [
        # –û—Å–Ω–æ–≤–Ω—ã–µ —Å–µ—Ç–∏
        '—Å—É–ø–µ—Ä–º–∞—Ä–∫–µ—Ç', '–ø—è—Ç–µ—Ä–æ—á–∫–∞', '–ø—è—Ç—ë—Ä–æ—á–∫–∞', '–ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–æ–∫', '–ø–µ—Ä–µ–∫—Ä—ë—Å—Ç–æ–∫', '–¥–∏–∫—Å–∏', '–º–∞–≥–Ω–∏—Ç',
        '–ª–µ–Ω—Ç–∞', '–∞—à–∞–Ω', '–∞—Ç–∞–∫', 'metro', 'spar', '–æ–∫–µ–π', '–≥–ª–æ–±—É—Å', '–∫–∞—Ä—É—Å–µ–ª—å',
        # –õ–æ–∫–∞–ª—å–Ω—ã–µ —Å–µ—Ç–∏
        '–≤–µ—Ä–Ω—ã–π', '–∞–≤–æ—Å—å–∫–∞', '–º–æ–Ω–µ—Ç–∫–∞', '–ø—Ä–∏–∑–º–∞', '—Å–µ–º–∏—à–∞–≥–æ—Ñ—Ñ', '—Ñ–∞—Å–æ–ª—å', '–≤–∫—É—Å–≤–∏–ª–ª',
        # –û–Ω–ª–∞–π–Ω —Å—É–ø–µ—Ä–º–∞—Ä–∫–µ—Ç—ã
        '—Å–∞–º–æ–∫–∞—Ç', '—è–Ω–¥–µ–∫—Å.–ª–∞–≤–∫–∞', '—Å–±–µ—Ä–º–∞—Ä–∫–µ—Ç', '–≤–ø—Ä–æ–∫', '–¥–µ–ª–∏–≤–µ—Ä–∏ –∫–ª–∞–±'
    ],
    '–ø—Ä–æ–¥—É–∫—Ç—ã': [
        # –û—Å–Ω–æ–≤–Ω—ã–µ –ø—Ä–æ–¥—É–∫—Ç—ã
        '–ø—Ä–æ–¥—É–∫—Ç—ã', '–µ–¥–∞', '–º–æ–ª–æ–∫–æ', '—Ö–ª–µ–±', '–º—è—Å–æ', '–æ–≤–æ—â–∏', '—Ñ—Ä—É–∫—Ç—ã', '—Ä—ã–±–∞', '–∫—É—Ä–∏—Ü–∞',
        'carrot', 'carrots', 'vegetable', 'vegetables',
        '—è–π—Ü–∞', '–º–∞—Å–ª–æ', '—Å—ã—Ä', '–∫–æ–ª–±–∞—Å–∞', '—Å–æ—Å–∏—Å–∫–∏', '–∫—Ä—É–ø–∞', '–º–∞–∫–∞—Ä–æ–Ω—ã', '—Å–∞—Ö–∞—Ä',
        # –ú–µ—Å—Ç–∞ –ø–æ–∫—É–ø–∫–∏
        '—Ä—ã–Ω–æ–∫', '–±–∞–∑–∞—Ä', '—è—Ä–º–∞—Ä–∫–∞', '–º—è—Å–Ω–∞—è –ª–∞–≤–∫–∞', '–±—É–ª–æ—á–Ω–∞—è', '–ø–µ–∫–∞—Ä–Ω—è',
        # –°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ
        '–≤–∫—É—Å–≤–∏–ª–ª', '–∞–∑–±—É–∫–∞ –≤–∫—É—Å–∞', '–º–∏—Ä–∞—Ç–æ—Ä–≥'
    ],
    '–∫–∞—Ñ–µ –∏ —Ä–µ—Å—Ç–æ—Ä–∞–Ω—ã': [
        # –û—Å–Ω–æ–≤–Ω—ã–µ
        '—Ä–µ—Å—Ç–æ—Ä–∞–Ω', '–∫–∞—Ñ–µ', '–∫–æ—Ñ–µ', '–æ–±–µ–¥', '–∑–∞–≤—Ç—Ä–∞–∫', '—É–∂–∏–Ω', '–ø–µ—Ä–µ–∫—É—Å', '–ª–∞–Ω—á', '–±–∏–∑–Ω–µ—Å-–ª–∞–Ω—á',
        # –ë–ª—é–¥–∞
        '–ø–∏—Ü—Ü–∞', '—Å—É—à–∏', '—Ä–æ–ª–ª—ã', '–±—É—Ä–≥–µ—Ä', '—à–∞—É—Ä–º–∞', '–ø–∞—Å—Ç–∞', '—Å–∞–ª–∞—Ç', '—Å—É–ø', '–¥–µ—Å–µ—Ä—Ç', '–º–æ—Ä–æ–∂–µ–Ω–æ–µ',
        # –ù–∞–ø–∏—Ç–∫–∏
        '–∫–∞–ø—É—á–∏–Ω–æ', '–ª–∞—Ç—Ç–µ', '—ç—Å–ø—Ä–µ—Å—Å–æ', '–∞–º–µ—Ä–∏–∫–∞–Ω–æ', '—Ä–∞—Ñ', '—Ñ–ª—ç—Ç —É–∞–π—Ç', '–º–∞–∫–∏–∞—Ç–æ', '—á–∞–π', '–∫–∞–∫–∞–æ',
        '—Ñ—Ä–∞–ø–ø–µ', '–≥–ª—è—Å—Å–µ', '–º–æ–∫–∫–æ', '–¥–æ–ø–ø–∏–æ', '—Ä–∏—Å—Ç—Ä–µ—Ç—Ç–æ', '–ª—É–Ω–≥–æ', '–∫–æ—Ä—Ç–∞–¥–æ',
        # –§–∞—Å—Ç—Ñ—É–¥
        '–º–∞–∫–¥–æ–Ω–∞–ª—å–¥—Å', '–º–∞–∫–¥–∞–∫', '–º–∞–∫', 'kfc', '–∫—Ñ—Å', '–±—É—Ä–≥–µ—Ä –∫–∏–Ω–≥', 'burger king', '–≤–∫—É—Å–Ω–æ –∏ —Ç–æ—á–∫–∞',
        # –ö–∞—Ñ–µ –∏ –∫–æ—Ñ–µ–π–Ω–∏
        '—Å—Ç–∞—Ä–±–∞–∫—Å', 'starbucks', '—à–æ–∫–æ–ª–∞–¥–Ω–∏—Ü–∞', '–∫–æ—Ñ–µ–º–∞–Ω–∏—è', 'costa', '–∫–æ—Ñ–µ —Ö–∞—É–∑', '–∫–æ—Ñ–µ–π–Ω—è',
        'one price coffee', '–¥–∞–±–ª–±–∏', 'surf coffee', '–ø—Ä–∞–≤–¥–∞ –∫–æ—Ñ–µ', '–∫–æ–æ–ø–µ—Ä–∞—Ç–∏–≤ —á–µ—Ä–Ω—ã–π',
        # –î–æ—Å—Ç–∞–≤–∫–∞ –µ–¥—ã
        '–¥–æ—Å—Ç–∞–≤–∫–∞', '—è–Ω–¥–µ–∫—Å.–µ–¥–∞', 'delivery club', '–¥–µ–ª–∏–≤–µ—Ä–∏', '—Å—É—à–∏', '–ø–∏—Ü—Ü–∞', '—Ä–æ–ª–ª—ã',
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ
        '—Å—Ç–æ–ª–æ–≤–∞—è', '–±–∞—Ä', '–ø–∞–±', '—Ä–µ—Å—Ç–æ—Ä–∞—Ü–∏—è', '—á–∞–µ–≤—ã–µ', '–∫—É–ª–∏–Ω–∞—Ä–∏—è', '–±–∏—Å—Ç—Ä–æ', '–ø–µ–∫–∞—Ä–Ω—è', '–∫–æ–Ω–¥–∏—Ç–µ—Ä—Å–∫–∞—è'
    ],
    '—Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç': [
        # –¢–∞–∫—Å–∏
        '—Ç–∞–∫—Å–∏', '—è–Ω–¥–µ–∫—Å', '—è–Ω–¥–µ–∫—Å.—Ç–∞–∫—Å–∏', 'uber', '—É–±–µ—Ä', 'gett', '–≥–µ—Ç—Ç', '—Å–∏—Ç–∏–º–æ–±–∏–ª', '–≤–µ–∑–µ—Ç',
        # –û–±—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç
        '–º–µ—Ç—Ä–æ', '–∞–≤—Ç–æ–±—É—Å', '—Ç—Ä–æ–ª–ª–µ–π–±—É—Å', '—Ç—Ä–∞–º–≤–∞–π', '–º–∞—Ä—à—Ä—É—Ç–∫–∞', '—ç–ª–µ–∫—Ç—Ä–∏—á–∫–∞', '–ø—Ä–æ–µ–∑–¥–Ω–æ–π',
        '—Ç—Ä–æ–π–∫–∞', '–µ–¥–∏–Ω—ã–π', '—Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–∞—è –∫–∞—Ä—Ç–∞', '–º—Ü–¥',
        # –ö–∞—Ä—à–µ—Ä–∏–Ω–≥
        '–∫–∞—Ä—à–µ—Ä–∏–Ω–≥', '–¥–µ–ª–∏–º–æ–±–∏–ª—å', '–±–µ–ª–∫–∞–∫–∞—Ä', '—è–Ω–¥–µ–∫—Å.–¥—Ä–∞–π–≤', '—Å–∏—Ç–∏–¥—Ä–∞–π–≤',
        # –°–∞–º–æ–∫–∞—Ç—ã
        '—Å–∞–º–æ–∫–∞—Ç', '–∫–∏–∫—à–µ—Ä–∏–Ω–≥', '—é—Ä–µ–Ω—Ç'
    ],
    '–∑–¥–æ—Ä–æ–≤—å–µ': [
        # –ê–ø—Ç–µ–∫–∏
        '–∞–ø—Ç–µ–∫–∞', '–ª–µ–∫–∞—Ä—Å—Ç–≤–∞', '—Ç–∞–±–ª–µ—Ç–∫–∏', '–≤–∏—Ç–∞–º–∏–Ω—ã', '–±–∞–¥—ã', '–º–µ–¥–∏–∫–∞–º–µ–Ω—Ç—ã', '–ø—Ä–µ–ø–∞—Ä–∞—Ç—ã',
        # –ú–µ–¥–∏—Ü–∏–Ω—Å–∫–∏–µ —É—Å–ª—É–≥–∏
        '–≤—Ä–∞—á', '–¥–æ–∫—Ç–æ—Ä', '–∫–ª–∏–Ω–∏–∫–∞', '–±–æ–ª—å–Ω–∏—Ü–∞', '–ø–æ–ª–∏–∫–ª–∏–Ω–∏–∫–∞', '–∞–Ω–∞–ª–∏–∑—ã', '—É–∑–∏', '–º—Ä—Ç',
        '—Å—Ç–æ–º–∞—Ç–æ–ª–æ–≥', '–∑—É–±–Ω–æ–π', '—Ç–µ—Ä–∞–ø–µ–≤—Ç', '–æ–∫—É–ª–∏—Å—Ç', '–º–∞—Å—Å–∞–∂',
        # –°–µ—Ç–∏ –∞–ø—Ç–µ–∫
        '—Ä–∏–≥–ª–∞', '–∞—Å–Ω–∞', '36.6', '–≥–æ—Ä–∑–¥—Ä–∞–≤', '—Å—Ç–æ–ª–∏—á–∫–∏', '–Ω–µ–æ—Ñ–∞—Ä–º',
        # –ú–µ–¥–∏—Ü–∏–Ω—Å–∫–∏–µ —Ü–µ–Ω—Ç—Ä—ã
        '–∏–Ω–≤–∏—Ç—Ä–æ', '–º–µ–¥—Å–∏', '—Å–º-–∫–ª–∏–Ω–∏–∫–∞'
    ],
    '–æ–¥–µ–∂–¥–∞ –∏ –æ–±—É–≤—å': [
        # –û—Å–Ω–æ–≤–Ω—ã–µ —Ç–∏–ø—ã
        '–æ–¥–µ–∂–¥–∞', '–æ–±—É–≤—å', '–¥–∂–∏–Ω—Å—ã', '—Ñ—É—Ç–±–æ–ª–∫–∞', '–∫—É—Ä—Ç–∫–∞', '–ø–ª–∞—Ç—å–µ', '–±–æ—Ç–∏–Ω–∫–∏', '—Ç—É—Ñ–ª–∏',
        '–∫—Ä–æ—Å—Å–æ–≤–∫–∏', '—Ä—É–±–∞—à–∫–∞', '—à—Ç–∞–Ω—ã', '—é–±–∫–∞', '–±—Ä—é–∫–∏', '–∫–æ—Å—Ç—é–º', '–ø–∞–ª—å—Ç–æ',
        # –ë—Ä–µ–Ω–¥—ã
        'zara', 'h&m', 'hm', 'uniqlo', 'mango', 'bershka', 'pull&bear', 'massimo dutti',
        'reserved', 'colin\'s', 'gloria jeans', '—Å–ø–æ—Ä—Ç–º–∞—Å—Ç–µ—Ä', '–¥–µ–∫–∞—Ç–ª–æ–Ω',
        # –ú–∞–≥–∞–∑–∏–Ω—ã
        '–ª–∞–º–æ–¥–∞', '—Ü–µ–Ω—Ç—Ä–æ–±—É–≤—å', '—ç–∫–∫–æ', '—Ä–∞–Ω–¥–µ–≤—É', '–≤–µ—â–µ–≤–æ–π —Ä—ã–Ω–æ–∫'
    ],
    '—Ä–∞–∑–≤–ª–µ—á–µ–Ω–∏—è': [
        # –û—Å–Ω–æ–≤–Ω—ã–µ
        '–∫–∏–Ω–æ', '—Ç–µ–∞—Ç—Ä', '–∫–æ–Ω—Ü–µ—Ä—Ç', '–∫–ª—É–±', '–±–∞—Ä', '–ø–∞–±', '–∏–≥—Ä—ã', '–±–æ—É–ª–∏–Ω–≥', '–∫–≤–µ—Å—Ç',
        '–∫–∞—Ä–∞–æ–∫–µ', '–±–∏–ª—å—è—Ä–¥', '–∫–∞—Ä—Ç–∏–Ω–≥', '–ø–µ–π–Ω—Ç–±–æ–ª', '–ª–∞–∑–µ—Ä—Ç–∞–≥',
        # –ö–∏–Ω–æ—Ç–µ–∞—Ç—Ä—ã
        '–∫–∏–Ω–æ—Ç–µ–∞—Ç—Ä', '–∫–∞—Ä–æ', '—Ñ–æ—Ä–º—É–ª–∞ –∫–∏–Ω–æ', '—Å–∏–Ω–µ–º–∞ –ø–∞—Ä–∫', 'imax', '–∫–∏–Ω–æ–º–∞–∫—Å',
        # –°–ø–æ—Ä—Ç
        '—Ñ–∏—Ç–Ω–µ—Å', '—Ç—Ä–µ–Ω–∞–∂–µ—Ä–Ω—ã–π –∑–∞–ª', '—Ç—Ä–µ–Ω–∞–∂–µ—Ä–∫–∞', '–±–∞—Å—Å–µ–π–Ω', '–π–æ–≥–∞', '—Ç–∞–Ω—Ü—ã', '—Å–µ–∫—Ü–∏—è',
        '—Å–ø–æ—Ä—Ç–∑–∞–ª', '—Ñ–∏—Ç–Ω–µ—Å-–∫–ª—É–±', '–∫–∞—Ç–æ–∫', '–ª—ã–∂–∏', '–∫–æ–Ω—å–∫–∏'
    ],
    '–¥–æ–º –∏ –∂–∫—Ö': [
        # –û—Å–Ω–æ–≤–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∏
        '–∂–∏–ª—å–µ', '–∫–≤–∞—Ä—Ç–∏—Ä–∞', '–¥–æ–º', '–∫–æ–º–º—É–Ω–∞–ª–∫–∞', '–∫–≤–∞—Ä—Ç–ø–ª–∞—Ç–∞', '–∂–∫—Ö', '—Å–≤–µ—Ç', '–≤–æ–¥–∞',
        '–≥–∞–∑', '–æ—Ç–æ–ø–ª–µ–Ω–∏–µ', '—ç–ª–µ–∫—Ç—Ä–∏—á–µ—Å—Ç–≤–æ', '–∫–∞–Ω–∞–ª–∏–∑–∞—Ü–∏—è', '–≤–æ–¥–æ–æ—Ç–≤–µ–¥–µ–Ω–∏–µ',
        # –ê—Ä–µ–Ω–¥–∞ –∏ –∏–ø–æ—Ç–µ–∫–∞
        '–∞—Ä–µ–Ω–¥–∞', '–∏–ø–æ—Ç–µ–∫–∞', '–Ω–∞–µ–º', '—Å—ä–µ–º',
        # –†–µ–º–æ–Ω—Ç –∏ –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–µ
        '—Ä–µ–º–æ–Ω—Ç', '—Å–∞–Ω—Ç–µ—Ö–Ω–∏–∫', '—ç–ª–µ–∫—Ç—Ä–∏–∫', '–∫–ª–∏–Ω–∏–Ω–≥', '—É–±–æ—Ä–∫–∞', '–¥–æ–º–æ—Ñ–æ–Ω',
        # –ú–µ–±–µ–ª—å –∏ —Ç–æ–≤–∞—Ä—ã –¥–ª—è –¥–æ–º–∞
        '–º–µ–±–µ–ª—å', 'ikea', '–∏–∫–µ—è', '–ª–µ—Ä—É–∞ –º–µ—Ä–ª–µ–Ω', 'obi', '—Å—Ç—Ä–æ–π–º–∞—Ç–µ—Ä–∏–∞–ª—ã'
    ],
    '—Å–≤—è–∑—å –∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç': [
        # –û—Å–Ω–æ–≤–Ω—ã–µ —É—Å–ª—É–≥–∏
        '—Å–≤—è–∑—å', '–∏–Ω—Ç–µ—Ä–Ω–µ—Ç', '—Ç–µ–ª–µ—Ñ–æ–Ω', '–º–æ–±–∏–ª—å–Ω—ã–π', '—Å–æ—Ç–æ–≤–∞—è',
        # –û–ø–µ—Ä–∞—Ç–æ—Ä—ã
        '–º—Ç—Å', '–±–∏–ª–∞–π–Ω', '–º–µ–≥–∞—Ñ–æ–Ω', '—Ç–µ–ª–µ–¥–≤–∞', '—Ç–µ–ª–µ2', '—Ä–æ—Å—Ç–µ–ª–µ–∫–æ–º', '–π–æ—Ç–∞',
        # –£—Å–ª—É–≥–∏
        '—Ç–∞—Ä–∏—Ñ', '–ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ', '—Ä–æ—É–º–∏–Ω–≥', '—Å–∏–º-–∫–∞—Ä—Ç–∞', 'sim'
    ],
    '–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ': [
        # –û—Å–Ω–æ–≤–Ω—ã–µ
        '–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ', '–∫—É—Ä—Å—ã', '—à–∫–æ–ª–∞', '—É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç', '—Ä–µ–ø–µ—Ç–∏—Ç–æ—Ä', '—É—á–µ–±–Ω–∏–∫–∏',
        '–æ–±—É—á–µ–Ω–∏–µ', '—Ç—Ä–µ–Ω–∏–Ω–≥', '—Å–µ–º–∏–Ω–∞—Ä', '–≤–µ–±–∏–Ω–∞—Ä', '–∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏—è',
        # –û–Ω–ª–∞–π–Ω –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
        'coursera', 'udemy', 'skillbox', 'geekbrains', '–Ω–µ—Ç–æ–ª–æ–≥–∏—è', '—è–Ω–¥–µ–∫—Å.–ø—Ä–∞–∫—Ç–∏–∫—É–º',
        # –Ø–∑—ã–∫–æ–≤—ã–µ –∫—É—Ä—Å—ã
        '–∞–Ω–≥–ª–∏–π—Å–∫–∏–π', 'english', 'skyeng', '–∏–Ω–≥–ª–µ–∫—Å'
    ],
    '–∞–≤—Ç–æ–º–æ–±–∏–ª—å': [
        # –û—Å–Ω–æ–≤–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã
        '–∞–≤—Ç–æ–º–æ–±–∏–ª—å', '–º–∞—à–∏–Ω–∞', '—Å—Ç–æ', '—Ä–µ–º–æ–Ω—Ç', '–∑–∞–ø—á–∞—Å—Ç–∏', '–º–æ–π–∫–∞', '–ø–∞—Ä–∫–æ–≤–∫–∞',
        '—à—Ç—Ä–∞—Ñ', '—Å—Ç—Ä–∞—Ö–æ–≤–∫–∞', '–∫–∞—Å–∫–æ', '–æ—Å–∞–≥–æ', '—Ç–µ—Ö–æ—Å–º–æ—Ç—Ä', '—à–∏–Ω–æ–º–æ–Ω—Ç–∞–∂',
        # –†–∞—Å—Ö–æ–¥–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã
        '–º–∞—Å–ª–æ', '—Ñ–∏–ª—å—Ç—Ä', '–∞–Ω—Ç–∏—Ñ—Ä–∏–∑', '—Ç–æ—Ä–º–æ–∑–Ω–∞—è –∂–∏–¥–∫–æ—Å—Ç—å', '–∞–∫–∫—É–º—É–ª—è—Ç–æ—Ä',
        # –£—Å–ª—É–≥–∏
        '—à–∏–Ω—ã', '—Ä–µ–∑–∏–Ω–∞', '–¥–∏—Å–∫–∏', '–ø–æ–∫—Ä–∞—Å–∫–∞', '–ø–æ–ª–∏—Ä–æ–≤–∫–∞'
    ],
    '–ø–æ–¥–∞—Ä–∫–∏': [
        # –û—Å–Ω–æ–≤–Ω—ã–µ
        '–ø–æ–¥–∞—Ä–æ–∫', '–ø–æ–¥–∞—Ä–∫–∏', '–¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è', '–¥—Ä', '–ø—Ä–∞–∑–¥–Ω–∏–∫', '—Å—É–≤–µ–Ω–∏—Ä',
        '—Ü–≤–µ—Ç—ã', '–±—É–∫–µ—Ç', '—Ä–æ–∑–∞', '—Ç—é–ª—å–ø–∞–Ω', '—Ü–≤–µ—Ç–æ—á–Ω—ã–π', '–æ—Ç–∫—Ä—ã—Ç–∫–∞',
        # –ü—Ä–∞–∑–¥–Ω–∏–∫–∏
        '–Ω–æ–≤—ã–π –≥–æ–¥', '8 –º–∞—Ä—Ç–∞', '23 —Ñ–µ–≤—Ä–∞–ª—è', '14 —Ñ–µ–≤—Ä–∞–ª—è', '—Ä–æ–∂–¥–µ—Å—Ç–≤–æ', '—Å–≤–∞–¥—å–±–∞'
    ],
    '–ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è': [
        # –û—Å–Ω–æ–≤–Ω—ã–µ
        '–ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ', '–æ—Ç–ø—É—Å–∫', '–±–∏–ª–µ—Ç', '–æ—Ç–µ–ª—å', '–≥–æ—Å—Ç–∏–Ω–∏—Ü–∞', '—Ö–æ—Å—Ç–µ–ª',
        '—Å–∞–º–æ–ª–µ—Ç', '–ø–æ–µ–∑–¥', '–≤–∏–∑–∞', '—Ç—É—Ä', '—ç–∫—Å–∫—É—Ä—Å–∏—è', '–±—Ä–æ–Ω—å',
        # –¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç
        '–∞—ç—Ä–æ–ø–æ—Ä—Ç', '–≤–æ–∫–∑–∞–ª', '—Ä–∂–¥', '–∞—ç—Ä–æ—Ñ–ª–æ—Ç', '–ø–æ–±–µ–¥–∞', 's7',
        # –ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
        'booking', 'airbnb', '–æ—Å—Ç—Ä–æ–≤–æ–∫', '—Ç—É—Ç—É.ru', '—è–Ω–¥–µ–∫—Å.–ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è'
    ],
    '–ø—Ä–æ—á–µ–µ': ['–ø—Ä–æ—á–µ–µ', '–¥—Ä—É–≥–æ–µ', '—Ä–∞–∑–Ω–æ–µ']
}


def detect_income_intent(text: str) -> bool:
    """
    –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–µ–∫—Å—Ç –¥–æ—Ö–æ–¥–æ–º –ø–æ –∑–Ω–∞–∫—É + –∏–ª–∏ —Å–ª–æ–≤—É "–ø–ª—é—Å"

    –ü—Ä–∏–º–µ—Ä—ã:
    - "+5000" -> True
    - "+5000 –∑–∞—Ä–ø–ª–∞—Ç–∞" -> True
    - "–¥–æ–ª–≥ +1200" -> True
    - "–ø–ª—é—Å 5000" -> True
    - "–∑–∞—Ä–ø–ª–∞—Ç–∞ –ø–ª—é—Å 3000" -> True
    - "–ø–ª—é—Å 1000 –¥–æ–ª–≥" -> True
    - "–∑–∞—Ä–ø–ª–∞—Ç–∞ 100000" -> False (–Ω–µ—Ç –∑–Ω–∞–∫–∞ + –∏–ª–∏ —Å–ª–æ–≤–∞ "–ø–ª—é—Å")
    - "–ø–æ–ª—É—á–∏–ª 5000" -> False (–Ω–µ—Ç –∑–Ω–∞–∫–∞ + –∏–ª–∏ —Å–ª–æ–≤–∞ "–ø–ª—é—Å")
    - "–∑–∞—Ä–∞–±–æ—Ç–∞–ª 3000" -> False (–Ω–µ—Ç –∑–Ω–∞–∫–∞ + –∏–ª–∏ —Å–ª–æ–≤–∞ "–ø–ª—é—Å")
    - "–∫–æ—Ñ–µ 200" -> False
    """
    if not text:
        return False
    
    text_lower = text.lower().strip()
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∑–Ω–∞–∫–∞ + –ø–µ—Ä–µ–¥ —á–∏—Å–ª–æ–º
    for pattern in INCOME_PATTERNS:
        if re.search(pattern, text_lower):
            return True
    
    return False


def detect_currency(text: str, user_currency: str = 'RUB') -> str:
    """Detect currency from text"""
    text_lower = text.lower()
    
    for currency, patterns in CURRENCY_PATTERNS.items():
        for pattern in patterns:
            if re.search(pattern, text_lower):
                return currency
    
    return (user_currency or 'RUB').upper()  # Default to user's currency in uppercase


async def parse_expense_message(text: str, user_id: Optional[int] = None, profile=None, use_ai: bool = True) -> Optional[Dict[str, Any]]:
    """
    –ü–∞—Ä—Å–∏—Ç —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∏–∑–≤–ª–µ–∫–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ä–∞—Å—Ö–æ–¥–µ

    –ü—Ä–∏–º–µ—Ä—ã:
    - "–ö–æ—Ñ–µ 200" -> {'amount': 200, 'description': '–ö–æ—Ñ–µ', 'category': '–∫–∞—Ñ–µ'}
    - "-200 –∫–æ—Ñ–µ" -> {'amount': 200, 'description': '–∫–æ—Ñ–µ', 'category': '–∫–∞—Ñ–µ'}
    - "–º–∏–Ω—É—Å 500 –æ–±–µ–¥" -> {'amount': 500, 'description': '–æ–±–µ–¥', 'category': '–∫–∞—Ñ–µ'}
    - "–î–∏–∑–µ–ª—å 4095 –ê–ó–°" -> {'amount': 4095, 'description': '–î–∏–∑–µ–ª—å –ê–ó–°', 'category': '—Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç'}
    - "–ü—Ä–æ–¥—É–∫—Ç—ã –≤ –ø—è—Ç–µ—Ä–æ—á–∫–µ 1500" -> {'amount': 1500, 'description': '–ü—Ä–æ–¥—É–∫—Ç—ã –≤ –ø—è—Ç–µ—Ä–æ—á–∫–µ', 'category': '–ø—Ä–æ–¥—É–∫—Ç—ã'}
    - "–ö–æ—Ñ–µ 200 15.03.2024" -> {'amount': 200, 'description': '–ö–æ—Ñ–µ', 'expense_date': date(2024, 3, 15)}
    - "25.12.2023 –ø–æ–¥–∞—Ä–∫–∏ 5000" -> {'amount': 5000, 'description': '–ø–æ–¥–∞—Ä–∫–∏', 'expense_date': date(2023, 12, 25)}
    """
    if not text:
        return None

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç
    original_text = text.strip()

    # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —á–∏—Å–ª–∞ —Å–ª–æ–≤–∞–º–∏ –≤ —Ü–∏—Ñ—Ä—ã (two -> 2, —Ç—Ä–∏ -> 3)
    original_text = convert_words_to_numbers(original_text)

    # –£–±–∏—Ä–∞–µ–º —Å–ª–æ–≤–∞-–º–∞—Ä–∫–µ—Ä—ã –æ–ø–µ—Ä–∞—Ü–∏–∏ (minus/–º–∏–Ω—É—Å/plus/–ø–ª—é—Å) –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –ø–æ—Å–ª–µ –Ω–∏—Ö –∏–¥—ë—Ç —á–∏—Å–ª–æ
    # –ü—Ä–∏–º–µ—Ä—ã:
    # "Carat minus 2" -> "Carat 2" (—É–¥–∞–ª—è–µ–º, —Ç.–∫. –ø–æ—Å–ª–µ "minus" –∏–¥—ë—Ç —Ü–∏—Ñ—Ä–∞)
    # "Apple minus two" -> "Apple two" -> "Apple 2" (—É–¥–∞–ª—è–µ–º, —Ç.–∫. –ø–æ—Å–ª–µ "minus" –∏–¥—ë—Ç —Å–ª–æ–≤–æ-—á–∏—Å–ª–æ)
    # "Minus store" -> "Minus store" (–ù–ï —É–¥–∞–ª—è–µ–º, —Ç.–∫. –ø–æ—Å–ª–µ "Minus" –ù–ï–¢ —á–∏—Å–ª–∞)
    text_cleaned = original_text

    # –°–æ–∑–¥–∞—ë–º –ø–∞—Ç—Ç–µ—Ä–Ω –∏–∑ –≤—Å–µ—Ö —Å–ª–æ–≤-—á–∏—Å–µ–ª
    number_words_pattern = '|'.join(re.escape(word) for word in WORD_TO_NUMBER.keys())

    # –£–¥–∞–ª—è–µ–º "minus/–º–∏–Ω—É—Å/plus/–ø–ª—é—Å" + –ø—Ä–æ–±–µ–ª—ã, –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –ø–æ—Å–ª–µ –Ω–∏—Ö –∏–¥—ë—Ç —Ü–∏—Ñ—Ä–∞ –∏–ª–∏ —Å–ª–æ–≤–æ-—á–∏—Å–ª–æ
    operation_pattern = r'\b(minus|–º–∏–Ω—É—Å|plus|–ø–ª—é—Å)\s+(?=\d|(?:' + number_words_pattern + r')\b)'
    text_cleaned = re.sub(operation_pattern, '', text_cleaned, flags=re.IGNORECASE)
    text_cleaned = ' '.join(text_cleaned.split())  # –£–±–∏—Ä–∞–µ–º –¥–≤–æ–π–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã

    # –£–±–∏—Ä–∞–µ–º –∑–Ω–∞–∫ "-" –∏–∑ –Ω–∞—á–∞–ª–∞ –µ—Å–ª–∏ –µ—Å—Ç—å
    if text_cleaned.startswith('-'):
        text_cleaned = text_cleaned[1:].strip()

    # –°–Ω–∞—á–∞–ª–∞ –∏–∑–≤–ª–µ–∫–∞–µ–º –¥–∞—Ç—É, –µ—Å–ª–∏ –æ–Ω–∞ –µ—Å—Ç—å
    expense_date, text_without_date = extract_date_from_text(text_cleaned)
    date_removed = text_without_date != text_cleaned

    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—Å—Ç –±–µ–∑ –¥–∞—Ç—ã –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞
    text_to_parse = text_without_date
    
    # –ò—â–µ–º —Å—É–º–º—É
    amount, text_without_amount = extract_amount_from_patterns(text_to_parse)

    if (not amount or amount <= 0) and date_removed:
        amount_with_date, text_without_amount_with_date = extract_amount_from_patterns(text_cleaned)
        if amount_with_date and amount_with_date > 0:
            amount = amount_with_date
            text_without_amount = text_without_amount_with_date
            text_to_parse = text_cleaned
            expense_date = None

    # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ —Å—É–º–º—É, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º None
    # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–ª–∂–µ–Ω —É–∫–∞–∑–∞—Ç—å —Å—É–º–º—É —è–≤–Ω–æ
    if not amount or amount <= 0:
        logger.debug(f"No amount found in text: {original_text}")
        return None

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
    category = None
    max_score = 0
    text_lower = text_to_parse.lower()  # –°–æ–∑–¥–∞–µ–º text_lower –¥–ª—è –ø–æ–∏—Å–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π

    # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏, –µ—Å–ª–∏ –µ—Å—Ç—å –ø—Ä–æ—Ñ–∏–ª—å
    if profile:
        from expenses.models import ExpenseCategory, CategoryKeyword
        from asgiref.sync import sync_to_async
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –∏—Ö –∫–ª—é—á–µ–≤—ã–º–∏ —Å–ª–æ–≤–∞–º–∏
        @sync_to_async
        def get_user_categories():
            return list(ExpenseCategory.objects.filter(profile=profile).prefetch_related('keywords'))
        
        user_categories = await get_user_categories()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        for user_cat in user_categories:
            user_cat_lower = user_cat.name.lower()
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä—è–º–æ–µ –≤—Ö–æ–∂–¥–µ–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤ —Ç–µ–∫—Å—Ç
            if user_cat_lower in text_lower:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
                lang_code = profile.language_code if hasattr(profile, 'language_code') else 'ru'
                category = get_category_display_name(user_cat, lang_code)
                max_score = 100  # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π
                break
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
            @sync_to_async
            def get_keywords():
                return list(user_cat.keywords.all())
            
            keywords = await get_keywords()
            for kw in keywords:
                if kw.keyword.lower() in text_lower:
                    # –û–±–Ω–æ–≤–ª—è–µ–º last_used –∏ usage_count –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞
                    @sync_to_async
                    def update_keyword_usage():
                        from django.utils import timezone
                        keyword = CategoryKeyword.objects.get(id=kw.id)
                        keyword.usage_count += 1
                        keyword.save(update_fields=['usage_count', 'last_used'])  # last_used –æ–±–Ω–æ–≤–∏—Ç—Å—è auto_now

                    await update_keyword_usage()

                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
                    lang_code = profile.language_code if hasattr(profile, 'language_code') else 'ru'
                    category = get_category_display_name(user_cat, lang_code)
                    max_score = 100
                    break
            
            if category:
                break
    
    # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö, –∏—â–µ–º –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö
    if not category:
        for cat_name, keywords in MODEL_CATEGORY_KEYWORDS.items():
            score = sum(1 for keyword in keywords if keyword.lower() in text_lower)
            if score > max_score:
                max_score = score
                category = cat_name
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ (—Ç–µ–∫—Å—Ç –±–µ–∑ —Å—É–º–º—ã –∏ –±–µ–∑ –¥–∞—Ç—ã)
    description = text_without_amount if text_without_amount is not None else text_without_date
    
    # –£–±–∏—Ä–∞–µ–º —Å–ª–æ–≤–∞-–º–∞—Ä–∫–µ—Ä—ã –≤—Ä–µ–º–µ–Ω–∏ –∏–∑ –æ–ø–∏—Å–∞–Ω–∏—è, –¥–∞–∂–µ –µ—Å–ª–∏ –æ–Ω–∏ –Ω–µ –±—ã–ª–∏ –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã –∫–∞–∫ –¥–∞—Ç—ã
    time_words = ['–≤—á–µ—Ä–∞', '–ø–æ–∑–∞–≤—á–µ—Ä–∞', '—Å–µ–≥–æ–¥–Ω—è', '–∑–∞–≤—Ç—Ä–∞']
    for word in time_words:
        description = re.sub(r'\b' + word + r'\b', '', description, flags=re.IGNORECASE)

    # –£–±–∏—Ä–∞–µ–º –æ–¥–∏–Ω–æ—á–Ω—ã–π –∑–Ω–∞–∫ "-" –∏–∑ –æ–ø–∏—Å–∞–Ω–∏—è (–º–æ–∂–µ—Ç –æ—Å—Ç–∞—Ç—å—Å—è –ø–æ—Å–ª–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Å—É–º–º—ã)
    # –í–∞–∂–Ω–æ: —É–¥–∞–ª—è–µ–º —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω–æ—á–Ω—ã–π –¥–µ—Ñ–∏—Å —Å –ø—Ä–æ–±–µ–ª–∞–º–∏, –Ω–µ –≤–Ω—É—Ç—Ä–∏ —Å–ª–æ–≤ (WiFi-—Ä–æ—É—Ç–µ—Ä)
    if description:
        description = re.sub(r'\s+-\s+', ' ', description)  # " - " ‚Üí " "
        description = re.sub(r'^\s*-\s*', '', description)  # "- " –≤ –Ω–∞—á–∞–ª–µ ‚Üí ""
        description = re.sub(r'\s*-\s*$', '', description)  # " -" –≤ –∫–æ–Ω—Ü–µ ‚Üí ""
        description = description.strip()

    # –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
    # –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: —Å–ª–æ–≤–∞-–º–∞—Ä–∫–µ—Ä—ã –æ–ø–µ—Ä–∞—Ü–∏–∏ (plus/minus/–ø–ª—é—Å/–º–∏–Ω—É—Å) —É–∂–µ —É–¥–∞–ª–µ–Ω—ã
    # –Ω–∞ —ç—Ç–∞–ø–µ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–µ–∫—Å—Ç–∞, –µ—Å–ª–∏ –æ–Ω–∏ —Å—Ç–æ—è–ª–∏ –ø–µ—Ä–µ–¥ —á–∏—Å–ª–æ–º
    description = ' '.join(description.split())
    if description:
        description = re.sub(r'[.,:;!?]+$', '', description).strip()
    
    # –ö–∞–ø–∏—Ç–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—É—é –±—É–∫–≤—É, –Ω–µ –º–µ–Ω—è—è —Ä–µ–≥–∏—Å—Ç—Ä –æ—Å—Ç–∞–ª—å–Ω—ã—Ö
    if description and len(description) > 0:
        description = description[0].upper() + description[1:] if len(description) > 1 else description.upper()
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤–∞–ª—é—Ç—É
    user_currency = (profile.currency if profile else 'RUB') or 'RUB'
    user_currency = user_currency.upper()
    currency = detect_currency(original_text, user_currency)
    
    # –ë–∞–∑–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç (–ù–ï –∑–∞–ø–æ–ª–Ω—è–µ–º category –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞)
    result = {
        'amount': float(amount),
        'description': description or '–†–∞—Å—Ö–æ–¥',
        'category': category,  # –û—Å—Ç–∞–≤–ª—è–µ–º None –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
        'currency': currency,
        'confidence': 0.5 if category else 0.2,
        'expense_date': expense_date  # –î–æ–±–∞–≤–ª—è–µ–º –¥–∞—Ç—É, –µ—Å–ª–∏ –æ–Ω–∞ –±—ã–ª–∞ —É–∫–∞–∑–∞–Ω–∞
    }

    # –ü–æ–ø—Ä–æ–±—É–µ–º —É–ª—É—á—à–∏—Ç—å —Å –ø–æ–º–æ—â—å—é AI, –µ—Å–ª–∏:
    # 1. –ù–µ –Ω–∞—à–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
    # 2. –ò–ª–∏ –Ω–∞—à–ª–∏, –Ω–æ –µ—ë –Ω–µ—Ç —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if use_ai and user_id and profile:
        should_use_ai = False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å AI
        if not category:
            should_use_ai = True
            logger.info(f"No category found by keywords for '{text}', will use AI")
        else:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ç–∞–∫–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            from expenses.models import ExpenseCategory
            from asgiref.sync import sync_to_async
            @sync_to_async
            def get_user_category_names():
                return list(ExpenseCategory.objects.filter(profile=profile).values_list('name', flat=True))
            
            user_categories = await get_user_category_names()
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ—á–Ω–æ–µ –∏ —á–∞—Å—Ç–∏—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
            category_exists = any(
                category.lower() in cat.lower() or cat.lower() in category.lower() 
                for cat in user_categories
            )
            
            if not category_exists:
                should_use_ai = True
                logger.info(f"Category '{category}' not found in user categories, will use AI")
        
        if should_use_ai:
            try:
                from bot.services.ai_selector import get_service
                
                # –ü–æ–ª—É—á–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                @sync_to_async
                def get_profile_categories():
                    return list(ExpenseCategory.objects.filter(profile=profile).values_list('name', flat=True))
                
                user_categories = await get_profile_categories()
                
                if user_categories:
                    # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–Ω–µ–¥–∞–≤–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏)
                    user_context = {}
                    @sync_to_async
                    def get_recent_expenses():
                        return list(
                            profile.expenses.select_related('category')
                            .order_by('-created_at')[:10]
                        )
                    
                    recent_expenses = await get_recent_expenses()
                    if recent_expenses:
                        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π
                        lang_code = profile.language_code if hasattr(profile, 'language_code') else 'ru'
                        recent_categories = list(set([
                            get_category_display_name(exp.category, lang_code) for exp in recent_expenses 
                            if exp.category
                        ]))[:3]
                        if recent_categories:
                            user_context['recent_categories'] = recent_categories
                    
                    # –ì–æ—Ç–æ–≤–∏–º —Ç–µ–∫—Å—Ç –¥–ª—è AI: —É–±–∏—Ä–∞–µ–º –ø—É–Ω–∫—Ç—É–∞—Ü–∏—é
                    # –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: operation words (plus/minus/–ø–ª—é—Å/–º–∏–Ω—É—Å) —É–∂–µ —É–¥–∞–ª–µ–Ω—ã –Ω–∞ —ç—Ç–∞–ø–µ
                    # –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏, –µ—Å–ª–∏ –æ–Ω–∏ —Å—Ç–æ—è–ª–∏ –ø–µ—Ä–µ–¥ —á–∏—Å–ª–æ–º
                    ai_text = text_without_date or original_text
                    if ai_text:
                        ai_text = ''.join(ch if ch.isalnum() or ch.isspace() else ' ' for ch in ai_text)
                        ai_text = ' '.join(ai_text.split())
                        if not ai_text:
                            ai_text = text_without_date or original_text

                    # –ü—Ä–æ–±—É–µ–º —Å–Ω–∞—á–∞–ª–∞ –æ—Å–Ω–æ–≤–Ω–æ–π AI —Å–µ—Ä–≤–∏—Å —Å —Ç–∞–π–º–∞—É—Ç–æ–º
                    try:
                        logger.info(f"Getting AI service for categorization...")
                        ai_service = get_service('categorization')
                        logger.info(f"AI service obtained: {type(ai_service).__name__}")
                        logger.info(f"Calling categorize_expense with timeout=15s...")
                        ai_result = await asyncio.wait_for(
                            ai_service.categorize_expense(
                                text=ai_text,  # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—á–∏—â–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –±–µ–∑ –¥–∞—Ç—ã
                                amount=amount,
                                currency=currency,
                                categories=user_categories,
                                user_context=user_context
                            ),
                            timeout=15.0  # 15 —Å–µ–∫—É–Ω–¥ –æ–±—â–∏–π —Ç–∞–π–º–∞—É—Ç –¥–ª—è –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
                        )
                        logger.info(f"AI categorization completed")
                    except asyncio.TimeoutError:
                        logger.warning(f"AI categorization timeout for '{original_text}'")
                        ai_result = None
                    except Exception as e:
                        logger.error(f"AI categorization error: {e}")
                        ai_result = None
                    
                    # –ï—Å–ª–∏ Google AI –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª, –ø—Ä–æ–±—É–µ–º OpenAI
                    if not ai_result:
                        logger.warning(f"Primary AI failed, trying fallback to OpenAI")
                        from bot.services.ai_selector import AISelector
                        try:
                            openai_service = AISelector('openai')
                            ai_result = await asyncio.wait_for(
                                openai_service.categorize_expense(
                                    text=ai_text,  # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—á–∏—â–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –±–µ–∑ –¥–∞—Ç—ã
                                    amount=amount,
                                    currency=currency,
                                    categories=user_categories,
                                    user_context=user_context
                                ),
                                timeout=5.0  # 5 —Å–µ–∫—É–Ω–¥ —Ç–∞–π–º–∞—É—Ç –¥–ª—è fallback
                            )
                            if ai_result:
                                logger.info(f"OpenAI fallback successful")
                        except asyncio.TimeoutError:
                            logger.error(f"OpenAI fallback timeout")
                        except Exception as e:
                            logger.error(f"OpenAI fallback failed: {e}")
                    
                    if ai_result:
                        # –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–∑ AI
                        result['category'] = ai_result.get('category', result['category'])
                        result['confidence'] = ai_result.get('confidence', result['confidence'])
                        result['ai_enhanced'] = True
                        result['ai_provider'] = ai_result.get('provider', 'unknown')
                        
                        # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –±–µ–∑ Unicode
                        try:
                            # –û—Å—Ç–∞–≤–ª—è–µ–º —ç–º–æ–¥–∑–∏ –Ω–æ —É–±–∏—Ä–∞–µ–º –∏—Ö –∏–∑ –ª–æ–≥–∞
                            if result['category']:
                                cat_clean = ''.join(c for c in result['category'] if ord(c) < 128).strip()
                                if not cat_clean and result['category']:
                                    cat_clean = 'category with emoji'
                                logger.info(f"AI enhanced result for user {user_id}: category='{cat_clean}', confidence={result['confidence']}, provider={result['ai_provider']}")
                        except (AttributeError, KeyError, TypeError) as e:
                            logger.debug(f"Error logging AI result: {e}")
                            pass
                    
            except Exception as e:
                logger.error(f"AI categorization failed: {e}")
    
    # –§–∏–Ω–∞–ª—å–Ω—ã–π fallback - –µ—Å–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—è –≤—Å–µ –µ—â–µ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞
    if not result['category']:
        result['category'] = '–ü—Ä–æ—á–∏–µ —Ä–∞—Å—Ö–æ–¥—ã'
        logger.info(f"Using default category '–ü—Ä–æ—á–∏–µ —Ä–∞—Å—Ö–æ–¥—ã' for '{original_text}'")
    
    return result


async def parse_income_message(text: str, user_id: Optional[int] = None, profile=None, use_ai: bool = True) -> Optional[Dict[str, Any]]:
    """
    –ü–∞—Ä—Å–∏—Ç —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∏–∑–≤–ª–µ–∫–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –¥–æ—Ö–æ–¥–µ
    
    –ü—Ä–∏–º–µ—Ä—ã:
    - "+5000" -> {'amount': 5000, 'description': '–î–æ—Ö–æ–¥', 'is_income': True}
    - "–∑–∞—Ä–ø–ª–∞—Ç–∞ 100000" -> {'amount': 100000, 'description': '–ó–∞—Ä–ø–ª–∞—Ç–∞', 'category': 'üíº –ó–∞—Ä–ø–ª–∞—Ç–∞'}
    - "–ø–æ–ª—É—á–∏–ª –ø—Ä–µ–º–∏—é 50000" -> {'amount': 50000, 'description': '–ü–æ–ª—É—á–∏–ª –ø—Ä–µ–º–∏—é', 'category': 'üéÅ –ü—Ä–µ–º–∏–∏ –∏ –±–æ–Ω—É—Å—ã'}
    """
    if not text:
        return None

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç
    original_text = text.strip()

    # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —á–∏—Å–ª–∞ —Å–ª–æ–≤–∞–º–∏ –≤ —Ü–∏—Ñ—Ä—ã (two -> 2, —Ç—Ä–∏ -> 3)
    original_text = convert_words_to_numbers(original_text)

    # –£–±–∏—Ä–∞–µ–º —Å–∏–º–≤–æ–ª + –≤ –Ω–∞—á–∞–ª–µ
    text_for_parsing = original_text
    if text_for_parsing.startswith('+'):
        text_for_parsing = text_for_parsing[1:].strip()

    # –£–±–∏—Ä–∞–µ–º —Å–ª–æ–≤–∞-–º–∞—Ä–∫–µ—Ä—ã –æ–ø–µ—Ä–∞—Ü–∏–∏ (plus/–ø–ª—é—Å) –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –ø–æ—Å–ª–µ –Ω–∏—Ö –∏–¥—ë—Ç —á–∏—Å–ª–æ
    # –ü—Ä–∏–º–µ—Ä—ã:
    # "Bonus plus 1000" -> "Bonus 1000" (—É–¥–∞–ª—è–µ–º, —Ç.–∫. –ø–æ—Å–ª–µ "plus" –∏–¥—ë—Ç —Ü–∏—Ñ—Ä–∞)
    # "Plus membership" -> "Plus membership" (–ù–ï —É–¥–∞–ª—è–µ–º, —Ç.–∫. –ø–æ—Å–ª–µ "Plus" –ù–ï–¢ —á–∏—Å–ª–∞)

    # –°–æ–∑–¥–∞—ë–º –ø–∞—Ç—Ç–µ—Ä–Ω –∏–∑ –≤—Å–µ—Ö —Å–ª–æ–≤-—á–∏—Å–µ–ª (–∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ —Å–ª–æ–≤–∞—Ä—å WORD_TO_NUMBER)
    number_words_pattern = '|'.join(re.escape(word) for word in WORD_TO_NUMBER.keys())

    # –£–¥–∞–ª—è–µ–º "plus/–ø–ª—é—Å" + –ø—Ä–æ–±–µ–ª—ã, –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –ø–æ—Å–ª–µ –Ω–∏—Ö –∏–¥—ë—Ç —Ü–∏—Ñ—Ä–∞ –∏–ª–∏ —Å–ª–æ–≤–æ-—á–∏—Å–ª–æ
    operation_pattern = r'\b(plus|–ø–ª—é—Å)\s+(?=\d|(?:' + number_words_pattern + r')\b)'
    text_for_parsing = re.sub(operation_pattern, '', text_for_parsing, flags=re.IGNORECASE)
    text_for_parsing = ' '.join(text_for_parsing.split())  # –£–±–∏—Ä–∞–µ–º –¥–≤–æ–π–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã
    
    # –°–Ω–∞—á–∞–ª–∞ –∏–∑–≤–ª–µ–∫–∞–µ–º –¥–∞—Ç—É, –µ—Å–ª–∏ –æ–Ω–∞ –µ—Å—Ç—å
    expense_date, text_without_date = extract_date_from_text(text_for_parsing)
    date_removed = text_without_date != text_for_parsing

    text_to_parse = text_without_date
    amount, text_without_amount = extract_amount_from_patterns(text_to_parse)

    if (not amount or amount <= 0) and date_removed:
        amount_with_date, text_without_amount_with_date = extract_amount_from_patterns(text_for_parsing)
        if amount_with_date and amount_with_date > 0:
            amount = amount_with_date
            text_without_amount = text_without_amount_with_date
            text_to_parse = text_for_parsing
            expense_date = None

    text_lower = text_to_parse.lower()

    # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ —Å—É–º–º—É, –ø—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–æ—Ö–æ–¥ —Å —Ç–∞–∫–∏–º –∂–µ –Ω–∞–∑–≤–∞–Ω–∏–µ–º
    if not amount or amount <= 0:
        if user_id:
            from bot.services.income import get_last_income_by_description
            # –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–æ—Ö–æ–¥ —Å –ø–æ—Ö–æ–∂–∏–º –æ–ø–∏—Å–∞–Ω–∏–µ–º
            last_income = await get_last_income_by_description(user_id, original_text)
            if last_income:
                amount = last_income.amount
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–æ—Ö–æ–¥–∞
                if last_income.category:
                    lang_code = profile.language_code if profile and hasattr(profile, 'language_code') else 'ru'
                    category = get_category_display_name(last_income.category, lang_code)
                else:
                    category = None
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—Å—Ç –±–µ–∑ –¥–∞—Ç—ã –∫–∞–∫ –æ–ø–∏—Å–∞–Ω–∏–µ
                description = text_without_date if text_without_date else original_text
                
                # –£–±–∏—Ä–∞–µ–º —Å–∏–º–≤–æ–ª + –∏–∑ –æ–ø–∏—Å–∞–Ω–∏—è –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
                if description and description.startswith('+'):
                    description = description[1:].strip()
                
                result = {
                    'amount': float(amount),
                    'description': description,
                    'income_date': expense_date or date.today(),
                    'income_type': last_income.income_type if hasattr(last_income, 'income_type') else 'other',
                    'currency': last_income.currency or 'RUB',
                    'is_income': True,
                    'similar_income': True,
                    'ai_enhanced': False,
                    'category_key': normalize_income_category_key(category) if category else None
                }
                if category:
                    result['category'] = category
                
                logger.info(f"Found similar income for '{original_text}': amount={amount}, category={category}")
                return result
        
        # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –ø–æ—Ö–æ–∂–∏–π –¥–æ—Ö–æ–¥, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º None
        return None
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–æ—Ö–æ–¥–∞
    category = None
    category_key = None
    income_type = 'other'
    ai_categorized = False
    ai_confidence = None

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π
    lang_code = 'ru'
    if profile and hasattr(profile, 'language_code') and profile.language_code:
        candidate_lang = profile.language_code.lower()
        if candidate_lang in ('ru', 'en'):
            lang_code = candidate_lang

    # –ü—ã—Ç–∞–µ–º—Å—è –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–º –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
    detected_key = detect_income_category_key(text_lower)
    if detected_key:
        category_key = detected_key
        category = get_income_category_display_for_key(category_key, lang_code)
        income_type = get_income_type(category_key)

    # –ï—Å–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –Ω–µ –Ω–∞—à–ª–∏, –ø—ã—Ç–∞–µ–º—Å—è –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —á–µ—Ä–µ–∑ AI
    if not category and profile and use_ai:
        from bot.services.income_categorization import categorize_income

        ai_result = await categorize_income(text_without_date if text_without_date else original_text, user_id, profile)

        if ai_result:
            ai_category_label = ai_result.get('category')
            ai_category_key = normalize_income_category_key(ai_category_label)
            if ai_category_key:
                category_key = ai_category_key
                category = get_income_category_display_for_key(ai_category_key, lang_code)
                income_type = get_income_type(ai_category_key)
            elif ai_category_label:
                category = ai_category_label

            if ai_result.get('description'):
                description = ai_result['description']
            if not amount and ai_result.get('amount'):
                amount = Decimal(str(ai_result['amount']))

            ai_categorized = True
            ai_confidence = ai_result.get('confidence', 0.5)

    # –ï—Å–ª–∏ AI –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª, –ø—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if not category and profile:
        from expenses.models import IncomeCategory, IncomeCategoryKeyword
        from asgiref.sync import sync_to_async

        try:
            @sync_to_async
            def get_income_keywords():
                return list(
                    IncomeCategoryKeyword.objects.filter(
                        category__profile=profile,
                        category__is_active=True
                    ).select_related('category')
                )

            keywords = await get_income_keywords()

            best_match = None
            best_weight = 0

            for keyword_obj in keywords:
                if keyword_obj.keyword.lower() in text_lower and keyword_obj.normalized_weight > best_weight:
                    best_match = keyword_obj.category
                    best_weight = keyword_obj.normalized_weight

            if best_match:
                category = get_category_display_name(best_match, lang_code)
                normalized_key = normalize_income_category_key(category)
                if normalized_key:
                    category_key = normalized_key
                    income_type = get_income_type(category_key)
        except Exception as e:
            logger.warning(f"Error checking income keywords: {e}")

        if not category:
            @sync_to_async
            def get_income_category_names():
                return list(IncomeCategory.objects.filter(profile=profile).values_list('name', flat=True))

            user_income_categories = await get_income_category_names()

            for user_cat in user_income_categories:
                lowered = user_cat.lower()
                if lowered in text_lower or any(word in lowered for word in text_lower.split()):
                    category = user_cat
                    normalized_key = normalize_income_category_key(user_cat)
                    if normalized_key:
                        category_key = normalized_key
                        category = get_income_category_display_for_key(category_key, lang_code)
                        income_type = get_income_type(category_key)
                    break

    # –§–∏–Ω–∞–ª—å–Ω—ã–µ —Å–æ–ø—Ä—è–∂–µ–Ω–∏—è
    if category and not category_key:
        normalized_key = normalize_income_category_key(category)
        if normalized_key:
            category_key = normalized_key
            category = get_income_category_display_for_key(category_key, lang_code)
            income_type = get_income_type(category_key)

    if not category:
        category_key = category_key or DEFAULT_INCOME_CATEGORY_KEY
        category = get_income_category_display_for_key(category_key, lang_code)
        income_type = get_income_type(category_key)

    # –§–æ—Ä–º–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ (–∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—Å—Ç –±–µ–∑ –¥–∞—Ç—ã –∏ –±–µ–∑ —Å—É–º–º—ã)
    description = text_without_amount if text_without_amount else (text_without_date if text_without_date else get_text('income', lang_code))

    # –£–±–∏—Ä–∞–µ–º –∑–Ω–∞–∫ "+" –∏–∑ –æ–ø–∏—Å–∞–Ω–∏—è
    if description:
        description = description.replace('+', '').strip()

    # –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã –∏ –∫–∞–ø–∏—Ç–∞–ª–∏–∑–∏—Ä—É–µ–º
    # –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: —Å–ª–æ–≤–∞-–º–∞—Ä–∫–µ—Ä—ã –æ–ø–µ—Ä–∞—Ü–∏–∏ (plus/–ø–ª—é—Å) —É–∂–µ —É–¥–∞–ª–µ–Ω—ã
    # –Ω–∞ —ç—Ç–∞–ø–µ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–µ–∫—Å—Ç–∞, –µ—Å–ª–∏ –æ–Ω–∏ —Å—Ç–æ—è–ª–∏ –ø–µ—Ä–µ–¥ —á–∏—Å–ª–æ–º
    description = ' '.join(description.split())
    if description and len(description) > 0:
        description = description[0].upper() + description[1:] if len(description) > 1 else description.upper()
    
    # –ï—Å–ª–∏ –æ–ø–∏—Å–∞–Ω–∏–µ –ø—É—Å—Ç–æ–µ –∏–ª–∏ —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–æ–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–ª–∏ —Ç–∏–ø –¥–æ—Ö–æ–¥–∞
    if not description or len(description) < 2:
        if category:
            # –£–±–∏—Ä–∞–µ–º —ç–º–æ–¥–∑–∏ –∏–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è
            description = re.sub(r'[^\w\s]', '', category).strip()
        elif income_type != 'other':
            type_descriptions = {
                'ru': {
                    'salary': '–ó–∞—Ä–ø–ª–∞—Ç–∞',
                    'bonus': '–ü—Ä–µ–º–∏—è',
                    'freelance': '–§—Ä–∏–ª–∞–Ω—Å',
                    'investment': '–ò–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏',
                    'interest': '–ü—Ä–æ—Ü–µ–Ω—Ç—ã',
                    'refund': '–í–æ–∑–≤—Ä–∞—Ç',
                    'cashback': '–ö–µ—à–±—ç–∫',
                    'gift': '–ü–æ–¥–∞—Ä–æ–∫',
                    'other': get_text('income', 'ru'),
                },
                'en': {
                    'salary': 'Salary',
                    'bonus': 'Bonus',
                    'freelance': 'Freelance',
                    'investment': 'Investments',
                    'interest': 'Interest',
                    'refund': 'Refund',
                    'cashback': 'Cashback',
                    'gift': 'Gift',
                    'other': 'Income',
                },
            }
            localized_map = type_descriptions['en'] if lang_code == 'en' else type_descriptions['ru']
            description = localized_map.get(income_type, localized_map['other'])
        else:
            description = get_text('income', lang_code)
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤–∞–ª—é—Ç—É
    user_currency = (profile.currency if profile else 'RUB') or 'RUB'
    user_currency = user_currency.upper()
    currency = detect_currency(original_text, user_currency)
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    result = {
        'amount': float(amount),
        'description': description,
        'category_key': category_key,
        'category': category,
        'income_type': income_type,
        'currency': currency,
        'confidence': ai_confidence if ai_confidence else (0.8 if category else 0.5),
        'income_date': expense_date,
        'is_income': True,  # –§–ª–∞–≥, —á—Ç–æ —ç—Ç–æ –¥–æ—Ö–æ–¥
        'ai_categorized': ai_categorized,
        'ai_confidence': ai_confidence
    }
    
    return result


async def extract_amount_from_text(text: str) -> Optional[float]:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Å—É–º–º—É –∏–∑ —Ç–µ–∫—Å—Ç–∞
    """
    parsed = await parse_expense_message(text, use_ai=False)
    return parsed['amount'] if parsed else None


def suggest_category(description: str) -> str:
    """
    –ü—Ä–µ–¥–ª–∞–≥–∞–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏—é –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ–ø–∏—Å–∞–Ω–∏—è
    """
    description_lower = description.lower()
    
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏–∑ models.py
    for category, keywords in MODEL_CATEGORY_KEYWORDS.items():
        for keyword in keywords:
            if keyword.lower() in description_lower:
                return category
    
    return '–ü—Ä–æ—á–∏–µ —Ä–∞—Å—Ö–æ–¥—ã'
