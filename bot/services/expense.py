"""
Service for expense management
"""
from asgiref.sync import sync_to_async
from datetime import datetime, date, timedelta
from decimal import Decimal
from typing import List, Optional, Dict, Any
import logging

from expenses.models import Expense, Profile, ExpenseCategory, Cashback
from django.db.models import Sum, Count
from django.db.models.functions import TruncDate
from bot.utils.db_utils import get_or_create_user_profile_sync

logger = logging.getLogger(__name__)


@sync_to_async
def create_expense(
    user_id: int,
    amount: Decimal,
    category_id: Optional[int] = None,
    description: Optional[str] = None,
    expense_date: Optional[date] = None,
    ai_categorized: bool = False,
    ai_confidence: Optional[float] = None,
    currency: str = 'RUB'
) -> Optional[Expense]:
    """
    Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ð½Ð¾Ð²ÑƒÑŽ Ñ‚Ñ€Ð°Ñ‚Ñƒ
    
    Args:
        user_id: ID Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Telegram
        amount: Ð¡ÑƒÐ¼Ð¼Ð° Ñ‚Ñ€Ð°Ñ‚Ñ‹
        category_id: ID ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸ (Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾)
        description: ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ñ‚Ñ€Ð°Ñ‚Ñ‹
        expense_date: Ð”Ð°Ñ‚Ð° Ñ‚Ñ€Ð°Ñ‚Ñ‹ (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ ÑÐµÐ³Ð¾Ð´Ð½Ñ)
        ai_categorized: ÐšÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð° AI
        ai_confidence: Ð£Ð²ÐµÑ€ÐµÐ½Ð½Ð¾ÑÑ‚ÑŒ AI Ð² ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸
        
    Returns:
        Expense instance Ð¸Ð»Ð¸ None Ð¿Ñ€Ð¸ Ð¾ÑˆÐ¸Ð±ÐºÐµ
    """
    profile = get_or_create_user_profile_sync(user_id)
    
    try:
        if expense_date is None:
            expense_date = date.today()
        
        # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð»Ð¸Ð¼Ð¸Ñ‚ Ñ€Ð°ÑÑ…Ð¾Ð´Ð¾Ð² Ð² Ð´ÐµÐ½ÑŒ (Ð¼Ð°ÐºÑÐ¸Ð¼ÑƒÐ¼ 100)
        today_expenses_count = Expense.objects.filter(
            profile=profile,
            expense_date=expense_date
        ).count()
        
        if today_expenses_count >= 100:
            logger.warning(f"User {user_id} reached daily expenses limit (100)")
            raise ValueError("Ð”Ð¾ÑÑ‚Ð¸Ð³Ð½ÑƒÑ‚ Ð»Ð¸Ð¼Ð¸Ñ‚ Ð·Ð°Ð¿Ð¸ÑÐµÐ¹ Ð² Ð´ÐµÐ½ÑŒ (Ð¼Ð°ÐºÑÐ¸Ð¼ÑƒÐ¼ 100). ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð·Ð°Ð²Ñ‚Ñ€Ð°.")
        
        # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð´Ð»Ð¸Ð½Ñƒ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ñ (Ð¼Ð°ÐºÑÐ¸Ð¼ÑƒÐ¼ 500 ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²)
        if description and len(description) > 500:
            logger.warning(f"User {user_id} provided too long description: {len(description)} chars")
            raise ValueError("ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ ÑÐ»Ð¸ÑˆÐºÐ¾Ð¼ Ð´Ð»Ð¸Ð½Ð½Ð¾Ðµ (Ð¼Ð°ÐºÑÐ¸Ð¼ÑƒÐ¼ 500 ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²)")
            
        expense = Expense.objects.create(
            profile=profile,
            category_id=category_id,
            amount=amount,
            currency=currency,
            description=description,
            expense_date=expense_date,
            ai_categorized=ai_categorized,
            ai_confidence=ai_confidence
        )
        
        logger.info(f"Created expense {expense.id} for user {user_id}")
        return expense
    except ValueError:
        raise  # ÐŸÑ€Ð¾Ð±Ñ€Ð°ÑÑ‹Ð²Ð°ÐµÐ¼ ValueError Ð´Ð°Ð»ÑŒÑˆÐµ
    except Exception as e:
        logger.error(f"Error creating expense: {e}")
        return None


# Alias for backward compatibility
add_expense = create_expense


@sync_to_async
def get_user_expenses(
    user_id: int,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    category_id: Optional[int] = None,
    limit: int = 50
) -> List[Expense]:
    """
    ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ‚Ñ€Ð°Ñ‚Ñ‹ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
    
    Args:
        user_id: ID Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Telegram
        start_date: ÐÐ°Ñ‡Ð°Ð»ÑŒÐ½Ð°Ñ Ð´Ð°Ñ‚Ð°
        end_date: ÐšÐ¾Ð½ÐµÑ‡Ð½Ð°Ñ Ð´Ð°Ñ‚Ð°
        category_id: Ð¤Ð¸Ð»ÑŒÑ‚Ñ€ Ð¿Ð¾ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸
        limit: ÐœÐ°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ðµ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð·Ð°Ð¿Ð¸ÑÐµÐ¹
        
    Returns:
        Ð¡Ð¿Ð¸ÑÐ¾Ðº Ñ‚Ñ€Ð°Ñ‚
    """
    profile = get_or_create_user_profile_sync(user_id)
    
    try:
        queryset = Expense.objects.filter(profile=profile)
        
        if start_date:
            queryset = queryset.filter(expense_date__gte=start_date)
        if end_date:
            queryset = queryset.filter(expense_date__lte=end_date)
        if category_id:
            queryset = queryset.filter(category_id=category_id)
            
        return list(queryset.select_related('category').order_by('-expense_date', '-created_at')[:limit])
        
        pass
    except Exception as e:
        logger.error(f"Error getting expenses: {e}")
        return []


@sync_to_async
def get_expenses_summary(
    user_id: int,
    start_date: date,
    end_date: date
) -> Dict:
    """
    ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ ÑÐ²Ð¾Ð´ÐºÑƒ Ñ‚Ñ€Ð°Ñ‚ Ð·Ð° Ð¿ÐµÑ€Ð¸Ð¾Ð´
    
    Args:
        user_id: ID Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Telegram
        start_date: ÐÐ°Ñ‡Ð°Ð»ÑŒÐ½Ð°Ñ Ð´Ð°Ñ‚Ð°
        end_date: ÐšÐ¾Ð½ÐµÑ‡Ð½Ð°Ñ Ð´Ð°Ñ‚Ð°
        
    Returns:
        Ð¡Ð»Ð¾Ð²Ð°Ñ€ÑŒ ÑÐ¾ ÑÐ²Ð¾Ð´ÐºÐ¾Ð¹:
        {
            'total': Decimal,
            'count': int,
            'by_category': List[Dict],
            'currency': str,
            'potential_cashback': Decimal
        }
    """
    profile = get_or_create_user_profile_sync(user_id)
    
    try:
        expenses = Expense.objects.filter(
            profile=profile,
            expense_date__gte=start_date,
            expense_date__lte=end_date
        )
        
        # ÐžÐ±Ñ‰Ð°Ñ ÑÑƒÐ¼Ð¼Ð° Ð¸ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾
        total = expenses.aggregate(total=Sum('amount'))['total'] or Decimal('0')
        count = expenses.count()
        
        # ÐŸÐ¾ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸ÑÐ¼
        by_category = expenses.values(
            'category__id',
            'category__name',
            'category__icon'
        ).annotate(
            total=Sum('amount'),
            count=Count('id')
        ).order_by('-total')
        
        # ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·ÑƒÐµÐ¼ Ð² ÑÐ¿Ð¸ÑÐ¾Ðº ÑÐ»Ð¾Ð²Ð°Ñ€ÐµÐ¹
        categories_list = []
        for cat in by_category:
            categories_list.append({
                'id': cat['category__id'],
                'name': cat['category__name'] or 'Ð‘ÐµÐ· ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸',
                'icon': cat['category__icon'] or 'ðŸ’°',
                'total': cat['total'],
                'count': cat['count']
            })
            
        # Ð Ð°ÑÑÑ‡Ð¸Ñ‚Ñ‹Ð²Ð°ÐµÐ¼ Ð¿Ð¾Ñ‚ÐµÐ½Ñ†Ð¸Ð°Ð»ÑŒÐ½Ñ‹Ð¹ ÐºÐµÑˆÐ±ÑÐº
        potential_cashback = Decimal('0')
        current_month = start_date.month
        
        # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ ÐºÐµÑˆÐ±ÑÐºÐ¸ Ð´Ð»Ñ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾ Ð¼ÐµÑÑÑ†Ð°
        cashbacks = Cashback.objects.filter(
            profile=profile,
            month=current_month
        ).select_related('category')
        
        # Ð¡Ð»Ð¾Ð²Ð°Ñ€ÑŒ ÐºÐµÑˆÐ±ÑÐºÐ¾Ð² Ð¿Ð¾ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸ÑÐ¼
        cashback_map = {}
        for cb in cashbacks:
            if cb.category_id not in cashback_map:
                cashback_map[cb.category_id] = []
            cashback_map[cb.category_id].append(cb)
            
        # Ð Ð°ÑÑÑ‡Ð¸Ñ‚Ñ‹Ð²Ð°ÐµÐ¼ ÐºÐµÑˆÐ±ÑÐº Ð´Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð¹ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸
        for cat in categories_list:
            if cat['id'] in cashback_map:
                # Ð‘ÐµÑ€ÐµÐ¼ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ñ‹Ð¹ ÐºÐµÑˆÐ±ÑÐº Ð¸Ð· Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ñ…
                max_cashback = max(cashback_map[cat['id']], key=lambda x: x.cashback_percent)
                
                # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð»Ð¸Ð¼Ð¸Ñ‚
                if max_cashback.limit_amount:
                    cashback_amount = min(
                        cat['total'] * max_cashback.cashback_percent / 100,
                        max_cashback.limit_amount
                    )
                else:
                    cashback_amount = cat['total'] * max_cashback.cashback_percent / 100
                    
                potential_cashback += cashback_amount
                
        return {
            'total': total,
            'count': count,
            'by_category': categories_list,
            'currency': profile.currency or 'RUB',
            'potential_cashback': potential_cashback
        }
        
        pass
    except Exception as e:
        logger.error(f"Error getting expenses summary: {e}")
        return {
            'total': Decimal('0'),
            'count': 0,
            'by_category': [],
            'currency': 'RUB',
            'potential_cashback': Decimal('0')
        }


@sync_to_async
def get_expenses_by_period(
    user_id: int,
    period: str = 'month'
) -> Dict:
    """
    ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ‚Ñ€Ð°Ñ‚Ñ‹ Ð·Ð° ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ñ‹Ð¹ Ð¿ÐµÑ€Ð¸Ð¾Ð´
    
    Args:
        user_id: ID Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Telegram
        period: ÐŸÐµÑ€Ð¸Ð¾Ð´ ('today', 'week', 'month', 'year')
        
    Returns:
        Ð¡Ð»Ð¾Ð²Ð°Ñ€ÑŒ ÑÐ¾ ÑÐ²Ð¾Ð´ÐºÐ¾Ð¹
    """
    today = date.today()
    
    if period == 'today':
        start_date = end_date = today
    elif period == 'week':
        start_date = today - timedelta(days=today.weekday())
        end_date = today
    elif period == 'month':
        start_date = today.replace(day=1)
        end_date = today
    elif period == 'year':
        start_date = today.replace(month=1, day=1)
        end_date = today
    else:
        # ÐŸÐ¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ - Ñ‚ÐµÐºÑƒÑ‰Ð¸Ð¹ Ð¼ÐµÑÑÑ†
        start_date = today.replace(day=1)
        end_date = today
        
    return get_expenses_summary(user_id, start_date, end_date)


@sync_to_async
def update_expense(
    user_id: int,
    expense_id: int,
    **kwargs
) -> bool:
    """
    ÐžÐ±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ñ‚Ñ€Ð°Ñ‚Ñƒ
    
    Args:
        user_id: ID Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Telegram
        expense_id: ID Ñ‚Ñ€Ð°Ñ‚Ñ‹
        **kwargs: ÐŸÐ¾Ð»Ñ Ð´Ð»Ñ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ
        
    Returns:
        True ÐµÑÐ»Ð¸ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾, False Ð¿Ñ€Ð¸ Ð¾ÑˆÐ¸Ð±ÐºÐµ
    """
    try:
        profile = Profile.objects.get(telegram_id=user_id)
    except Profile.DoesNotExist:
        logger.error(f"Profile not found for user {user_id}")
        return False
    
    try:
        expense = Expense.objects.get(id=expense_id, profile=profile)
        
        # Ð—Ð°Ð¿Ð¾Ð¼Ð¸Ð½Ð°ÐµÐ¼ ÑÑ‚Ð°Ñ€ÑƒÑŽ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸ÑŽ Ð´Ð»Ñ Ð¾Ð±ÑƒÑ‡ÐµÐ½Ð¸Ñ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹
        old_category_id = expense.category_id if expense.category else None
        
        # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, Ð¸Ð·Ð¼ÐµÐ½Ð¸Ð»Ð°ÑÑŒ Ð»Ð¸ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ
        category_changed = False
        new_category_id = kwargs.get('category_id')
        if new_category_id and new_category_id != old_category_id:
            category_changed = True
        
        # ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¿ÐµÑ€ÐµÐ´Ð°Ð½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»Ñ
        for field, value in kwargs.items():
            if hasattr(expense, field):
                setattr(expense, field, value)
                
        expense.save()
        logger.info(f"Updated expense {expense_id} for user {user_id}")
        
        # Ð•ÑÐ»Ð¸ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ð»Ð°ÑÑŒ, Ð·Ð°Ð¿ÑƒÑÐºÐ°ÐµÐ¼ Ñ„Ð¾Ð½Ð¾Ð²ÑƒÑŽ Ð·Ð°Ð´Ð°Ñ‡Ñƒ Ð´Ð»Ñ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ Ð²ÐµÑÐ¾Ð²
        if category_changed and old_category_id:
            from expense_bot.celery_tasks import update_keywords_weights
            update_keywords_weights.delay(
                expense_id=expense_id,
                old_category_id=old_category_id,
                new_category_id=new_category_id
            )
            logger.info(f"Triggered keywords weights update for expense {expense_id}")
        
        return True
        
    except Expense.DoesNotExist:
        logger.error(f"Expense {expense_id} not found for user {user_id}")
        return False
    except Exception as e:
        logger.error(f"Error updating expense: {e}")
        return False


@sync_to_async
def get_expense_by_id(expense_id: int, telegram_id: int) -> Optional[Expense]:
    """
    ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ‚Ñ€Ð°Ñ‚Ñƒ Ð¿Ð¾ ID
    
    Args:
        expense_id: ID Ñ‚Ñ€Ð°Ñ‚Ñ‹
        telegram_id: ID Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Telegram
        
    Returns:
        Expense instance Ð¸Ð»Ð¸ None
    """
    try:
        profile = Profile.objects.get(telegram_id=telegram_id)
        return Expense.objects.select_related('category').get(id=expense_id, profile=profile)
    except (Profile.DoesNotExist, Expense.DoesNotExist):
        return None
    except Exception as e:
        logger.error(f"Error getting expense by id: {e}")
        return None


@sync_to_async
def get_user_expenses(
    telegram_id: int,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    category_id: Optional[int] = None,
    limit: int = 50
) -> List[Expense]:
    """
    ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ‚Ñ€Ð°Ñ‚Ñ‹ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ñ Ñ„Ð¸Ð»ÑŒÑ‚Ñ€Ð°Ñ†Ð¸ÐµÐ¹
    
    Args:
        telegram_id: ID Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Telegram
        start_date: ÐÐ°Ñ‡Ð°Ð»ÑŒÐ½Ð°Ñ Ð´Ð°Ñ‚Ð° (Ð²ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾)
        end_date: ÐšÐ¾Ð½ÐµÑ‡Ð½Ð°Ñ Ð´Ð°Ñ‚Ð° (Ð²ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾)
        category_id: ID ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸ Ð´Ð»Ñ Ñ„Ð¸Ð»ÑŒÑ‚Ñ€Ð°Ñ†Ð¸Ð¸
        limit: ÐœÐ°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ðµ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð·Ð°Ð¿Ð¸ÑÐµÐ¹
        
    Returns:
        Ð¡Ð¿Ð¸ÑÐ¾Ðº Ñ‚Ñ€Ð°Ñ‚
    """
    try:
        profile = Profile.objects.get(telegram_id=telegram_id)
        
        queryset = Expense.objects.filter(profile=profile)
        
        if start_date:
            queryset = queryset.filter(expense_date__gte=start_date)
        if end_date:
            queryset = queryset.filter(expense_date__lte=end_date)
        if category_id:
            queryset = queryset.filter(category_id=category_id)
            
        return list(queryset.select_related('category').order_by('-expense_date', '-expense_time')[:limit])
        
    except Profile.DoesNotExist:
        logger.error(f"Profile not found for user {telegram_id}")
        return []
    except Exception as e:
        logger.error(f"Error getting user expenses: {e}")
        return []


@sync_to_async
def find_similar_expenses(
    telegram_id: int,
    description: str,
    days_back: int = 365
) -> List[Dict[str, Any]]:
    """
    ÐÐ°Ð¹Ñ‚Ð¸ Ð¿Ð¾Ñ…Ð¾Ð¶Ð¸Ðµ Ñ‚Ñ€Ð°Ñ‚Ñ‹ Ð·Ð° Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ð¿ÐµÑ€Ð¸Ð¾Ð´
    
    Args:
        telegram_id: ID Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Telegram
        description: ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð´Ð»Ñ Ð¿Ð¾Ð¸ÑÐºÐ°
        days_back: ÐšÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð´Ð½ÐµÐ¹ Ð½Ð°Ð·Ð°Ð´ Ð´Ð»Ñ Ð¿Ð¾Ð¸ÑÐºÐ° (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ Ð³Ð¾Ð´)
        
    Returns:
        Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð¿Ð¾Ñ…Ð¾Ð¶Ð¸Ñ… Ñ‚Ñ€Ð°Ñ‚ Ñ ÑƒÐ½Ð¸ÐºÐ°Ð»ÑŒÐ½Ñ‹Ð¼Ð¸ ÑÑƒÐ¼Ð¼Ð°Ð¼Ð¸
    """
    try:
        profile = Profile.objects.get(telegram_id=telegram_id)
        
        # ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼ Ð¿ÐµÑ€Ð¸Ð¾Ð´ Ð¿Ð¾Ð¸ÑÐºÐ°
        end_date = date.today()
        start_date = end_date - timedelta(days=days_back)
        
        # ÐÐ¾Ñ€Ð¼Ð°Ð»Ð¸Ð·ÑƒÐµÐ¼ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð´Ð»Ñ Ð¿Ð¾Ð¸ÑÐºÐ°
        search_desc = description.lower().strip()
        
        # Ð˜Ñ‰ÐµÐ¼ Ñ‚Ñ€Ð°Ñ‚Ñ‹ Ñ Ð¿Ð¾Ñ…Ð¾Ð¶Ð¸Ð¼ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸ÐµÐ¼
        queryset = Expense.objects.filter(
            profile=profile,
            expense_date__gte=start_date,
            expense_date__lte=end_date
        )
        
        # Ð¤Ð¸Ð»ÑŒÑ‚Ñ€ÑƒÐµÐ¼ Ð¿Ð¾ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸ÑŽ (Ñ‚Ð¾Ñ‡Ð½Ð¾Ðµ ÑÐ¾Ð²Ð¿Ð°Ð´ÐµÐ½Ð¸Ðµ Ð¸Ð»Ð¸ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ñ‚)
        similar_expenses = []
        for expense in queryset.select_related('category'):
            if expense.description:
                exp_desc = expense.description.lower().strip()
                # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ñ‚Ð¾Ñ‡Ð½Ð¾Ðµ ÑÐ¾Ð²Ð¿Ð°Ð´ÐµÐ½Ð¸Ðµ Ð¸Ð»Ð¸ Ð²Ñ…Ð¾Ð¶Ð´ÐµÐ½Ð¸Ðµ
                if exp_desc == search_desc or search_desc in exp_desc or exp_desc in search_desc:
                    similar_expenses.append(expense)
        
        # Ð“Ñ€ÑƒÐ¿Ð¿Ð¸Ñ€ÑƒÐµÐ¼ Ð¿Ð¾ ÑƒÐ½Ð¸ÐºÐ°Ð»ÑŒÐ½Ñ‹Ð¼ ÑÑƒÐ¼Ð¼Ð°Ð¼ Ð¸ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸ÑÐ¼
        unique_amounts = {}
        for expense in similar_expenses:
            key = (float(expense.amount), expense.currency, expense.category.name if expense.category else 'ÐŸÑ€Ð¾Ñ‡Ð¸Ðµ Ñ€Ð°ÑÑ…Ð¾Ð´Ñ‹')
            if key not in unique_amounts:
                unique_amounts[key] = {
                    'amount': float(expense.amount),
                    'currency': expense.currency,
                    'category': expense.category.name if expense.category else 'ÐŸÑ€Ð¾Ñ‡Ð¸Ðµ Ñ€Ð°ÑÑ…Ð¾Ð´Ñ‹',
                    'count': 1,
                    'last_date': expense.expense_date
                }
            else:
                unique_amounts[key]['count'] += 1
                if expense.expense_date > unique_amounts[key]['last_date']:
                    unique_amounts[key]['last_date'] = expense.expense_date
        
        # Ð¡Ð¾Ñ€Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ð¿Ð¾ Ñ‡Ð°ÑÑ‚Ð¾Ñ‚Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¸ Ð´Ð°Ñ‚Ðµ
        result = sorted(
            unique_amounts.values(),
            key=lambda x: (x['count'], x['last_date']),
            reverse=True
        )
        
        return result[:5]  # Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ñ‚Ð¾Ð¿-5 Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚Ð¾Ð²
        
    except Profile.DoesNotExist:
        logger.error(f"Profile not found for user {telegram_id}")
        return []
    except Exception as e:
        logger.error(f"Error finding similar expenses: {e}")
        return []


@sync_to_async
def delete_expense(telegram_id: int, expense_id: int) -> bool:
    """
    Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ñ‚Ñ€Ð°Ñ‚Ñƒ
    
    Args:
        telegram_id: ID Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Telegram
        expense_id: ID Ñ‚Ñ€Ð°Ñ‚Ñ‹
        
    Returns:
        True ÐµÑÐ»Ð¸ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾, False Ð¿Ñ€Ð¸ Ð¾ÑˆÐ¸Ð±ÐºÐµ
    """
    try:
        profile = Profile.objects.get(telegram_id=telegram_id)
    except Profile.DoesNotExist:
        logger.error(f"Profile not found for user {telegram_id}")
        return False
    
    try:
        expense = Expense.objects.get(id=expense_id, profile=profile)
        expense.delete()
        
        logger.info(f"Deleted expense {expense_id} for user {telegram_id}")
        return True
        
    except Expense.DoesNotExist:
        logger.error(f"Expense {expense_id} not found for user {telegram_id}")
        return False
    except Exception as e:
        logger.error(f"Error deleting expense: {e}")
        return False


@sync_to_async
def get_last_expense(telegram_id: int) -> Optional[Expense]:
    """
    ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÑŽÑŽ Ñ‚Ñ€Ð°Ñ‚Ñƒ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
    
    Args:
        user_id: ID Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Telegram
        
    Returns:
        Expense instance Ð¸Ð»Ð¸ None
    """
    profile = get_or_create_user_profile_sync(user_id)
    
    try:
        return Expense.objects.filter(profile=profile).order_by('-created_at').first()
    except Exception as e:
        logger.error(f"Error getting last expense: {e}")
        return None


async def get_today_summary(user_id: int) -> Dict[str, Any]:
    """Get today's expense summary with multi-currency support"""
    from expenses.models import Profile
    
    try:
        profile = await Profile.objects.aget(telegram_id=user_id)
        today = date.today()
        
        expenses = await sync_to_async(list)(
            Expense.objects.filter(
                profile=profile,
                expense_date=today
            ).select_related('category')
        )
        
        # Group by currency
        currency_totals = {}
        for expense in expenses:
            currency = expense.currency or 'RUB'
            if currency not in currency_totals:
                currency_totals[currency] = Decimal('0')
            currency_totals[currency] += expense.amount
        
        # Get user's primary currency
        user_currency = profile.currency or 'RUB'
        
        # Keep currencies separate
        # Total will be shown per currency
        single_currency = len(currency_totals) == 1
        # For single currency, use that total
        if single_currency and user_currency in currency_totals:
            total = float(currency_totals[user_currency])
        else:
            # For multiple currencies, show main currency total
            total = float(currency_totals.get(user_currency, 0))
        
        # Group by category and currency
        categories_by_currency = {}
        for expense in expenses:
            if expense.category:
                currency = expense.currency or 'RUB'
                if currency not in categories_by_currency:
                    categories_by_currency[currency] = {}
                
                cat_key = expense.category.id
                if cat_key not in categories_by_currency[currency]:
                    categories_by_currency[currency][cat_key] = {
                        'name': expense.category.name,
                        'icon': expense.category.icon,
                        'amount': Decimal('0'),
                        'currency': currency
                    }
                categories_by_currency[currency][cat_key]['amount'] += expense.amount
        
        # Combine categories from all currencies
        all_categories = []
        for currency, cats in categories_by_currency.items():
            for cat in cats.values():
                all_categories.append(cat)
        
        # Sort by amount (note: mixed currencies, but at least shows all)
        sorted_categories = sorted(
            all_categories,
            key=lambda x: x['amount'],
            reverse=True
        )
        
        return {
            'total': total,
            'count': len(expenses),
            'categories': sorted_categories,
            'currency': user_currency,
            'currency_totals': {k: float(v) for k, v in currency_totals.items()},
            'single_currency': single_currency
        }
        
    except Profile.DoesNotExist:
        return {'total': 0, 'count': 0, 'categories': [], 'currency': 'RUB', 'currency_totals': {}, 'single_currency': True}
    except Exception as e:
        logger.error(f"Error getting today summary: {e}")
        return {'total': 0, 'count': 0, 'categories': [], 'currency': 'RUB', 'currency_totals': {}, 'single_currency': True}


async def get_month_summary(user_id: int, month: int, year: int) -> Dict[str, Any]:
    """Get monthly expense summary with multi-currency support"""
    from expenses.models import Profile
    
    try:
        profile = await Profile.objects.aget(telegram_id=user_id)
        
        expenses = await sync_to_async(list)(
            Expense.objects.filter(
                profile=profile,
                expense_date__month=month,
                expense_date__year=year
            ).select_related('category')
        )
        
        # Group by currency
        currency_totals = {}
        for expense in expenses:
            currency = expense.currency or 'RUB'
            if currency not in currency_totals:
                currency_totals[currency] = Decimal('0')
            currency_totals[currency] += expense.amount
        
        # Get user's primary currency
        user_currency = profile.currency or 'RUB'
        
        # Keep currencies separate
        # Total will be shown per currency
        single_currency = len(currency_totals) == 1
        # For single currency, use that total
        if single_currency and user_currency in currency_totals:
            total = float(currency_totals[user_currency])
        else:
            # For multiple currencies, show main currency total
            total = float(currency_totals.get(user_currency, 0))
        
        # Group by category and currency
        categories_by_currency = {}
        for expense in expenses:
            if expense.category:
                currency = expense.currency or 'RUB'
                if currency not in categories_by_currency:
                    categories_by_currency[currency] = {}
                
                cat_key = expense.category.id
                if cat_key not in categories_by_currency[currency]:
                    categories_by_currency[currency][cat_key] = {
                        'name': expense.category.name,
                        'icon': expense.category.icon,
                        'amount': Decimal('0'),
                        'currency': currency
                    }
                categories_by_currency[currency][cat_key]['amount'] += expense.amount
        
        # Combine categories from all currencies
        all_categories = []
        for currency, cats in categories_by_currency.items():
            for cat in cats.values():
                all_categories.append(cat)
        
        # Sort by amount (note: mixed currencies, but at least shows all)
        sorted_categories = sorted(
            all_categories,
            key=lambda x: x['amount'],
            reverse=True
        )
        
        return {
            'total': total,
            'count': len(expenses),
            'categories': sorted_categories,
            'currency': user_currency,
            'currency_totals': {k: float(v) for k, v in currency_totals.items()},
            'single_currency': single_currency
        }
        
    except Profile.DoesNotExist:
        return {'total': 0, 'count': 0, 'categories': [], 'currency': 'RUB', 'currency_totals': {}, 'single_currency': True}
    except Exception as e:
        logger.error(f"Error getting month summary: {e}")
        return {'total': 0, 'count': 0, 'categories': [], 'currency': 'RUB', 'currency_totals': {}, 'single_currency': True}