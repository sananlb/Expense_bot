# Инцидент: Аппаратный сбой сервера 07.02.2026

## Общая информация

| Параметр | Значение |
|----------|----------|
| **Дата** | 07 февраля 2026 |
| **Сервер** | PRIMARY (176.124.218.53) |
| **Причина** | Аппаратный сбой ноды хостера |
| **Время простоя** | ~1 час 24 минуты |
| **Потеря данных** | Нет (подтверждено) |
| **Затронутые пользователи** | Все (бот был полностью недоступен) |

---

## Хронология событий

### До инцидента (нормальная работа)

| Время (MSK) | Событие |
|-------------|---------|
| 13:32:04 | user 881292737 — `/expenses`, `/categories`, `/recurring`, редактирование суммы платежа ID=18 (9900 KZT) |
| 13:40:40 | user 5081318925 — запись траты `4990 кроватьа14`, AI-категоризация (DeepSeek), редактирование |
| 14:21:01 | Rate limiter stats: 71 запрос, 0 заблокировано, 2 уникальных пользователя |
| 14:33:25 | user 464766457 — запись траты `2102.6 аптека` |
| 14:37:13 | user 348740371 — запись траты `40 транспорт` — **ПОСЛЕДНИЙ УСПЕШНЫЙ ЗАПРОС** |

### Инцидент

| Время (MSK) | Событие |
|-------------|---------|
| ~14:37–15:16 | **Сервер недоступен.** Никаких логов. Ping — 100% потерь. SSH — Connection timed out |
| ~15:16 | Хостер восстановил ноду. Docker-контейнеры начали подниматься |
| 15:16–16:01 | **DNS не работал на ноде.** Бот циклически перезапускался (~48 раз) |
| 16:01:16 | DNS восстановлен. **Бот успешно запустился.** Webhook установлен |
| 16:01:27 | Первый запрос после восстановления: user 348740371 — `1539 авито` |

### Общее время простоя

```
Начало:   ~14:37 (последний успешный запрос, точное время падения неизвестно)
Конец:    16:01 (первый запрос после восстановления)
Простой:  ~1 час 24 минуты
```

**Примечание:** Точное время падения неизвестно — может быть от 14:37 до 15:16. Мы знаем только последний успешный запрос и первый лог после перезагрузки.

---

## Детали проблемы

### Фаза 1: Аппаратный сбой (~14:37 – ~15:16)

- Нода хостера вышла из строя
- Сервер полностью недоступен (ping, SSH — таймаут)
- Предупреждение в панели хостера: "Аппаратный сбой на ноде, где расположен ваш сервер. Мы уже решаем проблему и скоро всё починим. Все ваши данные на месте, но пока идут работы, ваш проект может быть недоступен."
- **На нашей стороне сделать ничего нельзя — полная зависимость от хостера**

### Фаза 2: DNS не работает, бот циклически крашится (~15:16 – ~16:01, ~45 минут)

Сервер поднялся, Docker запустил контейнеры, но DNS-резолвер ноды ещё не восстановился.

#### Установленная причина крашей

**Важно:** Первоначальная гипотеза "бот крашится из-за `set_webhook()`" — **НЕВЕРНА**.

Расследование кода показало:
- `set_webhook()` в `bot/main.py:286-295` **обёрнут в try/except** — исключение ловится корректно
- Веб-сервер (`web.TCPSite`) запускается **ПОСЛЕ** try/except (строки 300-305) — должен работать независимо от результата set_webhook

**Реальная причина краша — `set_bot_commands()` в `on_startup()`:**

```
bot/main.py:69  → on_startup(bot) вызывается при старте диспетчера
bot/main.py:71  → await set_bot_commands(bot)
bot/utils/commands.py:21 → await bot.set_my_commands(...) ← БЕЗ try/except!
```

Цепочка:
1. `main_webhook()` → `setup_application(app, dp, bot=bot)` подключает lifecycle
2. `runner.setup()` или `site.start()` запускает aiohttp app → триггерит `dp.startup`
3. `on_startup()` вызывает `set_bot_commands(bot)`
4. `set_bot_commands()` делает `bot.set_my_commands()` → Telegram API → DNS ошибка
5. **Исключение НЕ перехвачено** → аварийное завершение процесса
6. aiohttp логирует "Unclosed client session" при очистке
7. Docker (`restart: unless-stopped`) перезапускает контейнер

**Доказательства из логов:**
```
ERROR 2026-02-07 15:17:05 main ❌ Ошибка установки webhook: ClientConnectorDNSError ...
WARN  2026-02-07 15:17:05 main ⚠️ Бот продолжит работу, но webhook может не работать
ERROR 2026-02-07 15:17:21 base_events Unclosed client session
client_session: <aiohttp.client.ClientSession object at 0x726258d8d550>
Starting Expense Bot container...    ← Контейнер ПЕРЕЗАПУЩЕН (docker-entrypoint.sh)
Waiting for PostgreSQL...
```

Обратите внимание: между "Бот продолжит работу" и перезапуском контейнера проходит ~16 секунд — это время, за которое aiohttp пытается запуститься, вызывает `on_startup` → `set_bot_commands` → DNS fail → crash.

**Цикл перезапуска (~48 сек на итерацию):**
1. Docker запускает контейнер
2. `docker-entrypoint.sh`: ожидание PostgreSQL + Redis, миграции, collectstatic (~30 сек)
3. `python -m bot.main` → `main_webhook()`
4. `set_webhook()` → DNS fail → **пойман** → warning
5. `runner.setup()` → `on_startup()` → `set_bot_commands()` → DNS fail → **НЕ пойман** → crash
6. Docker restart → повтор с шага 1

### Фаза 3: Celery Beat спам (~15:16 – ~16:01)

Параллельно с ботом, контейнеры celery и celery-beat тоже перезапускались.
Beat при каждом запуске выполнял `[Beat setup] Ensured PeriodicTasks: ...` — это не ошибка, просто шум в логах.

---

## Влияние на пользователей

| Аспект | Статус | Детали |
|--------|--------|--------|
| Потеря записанных трат | **Нет** | Все данные в БД PostgreSQL сохранены (volume `postgres_data` переживает рестарт) |
| Пропущенные сообщения | **Возможна задержка/частичная потеря** | Telegram при webhook-режиме делает ретраи при ошибках доставки, но с ограниченным числом попыток. Сообщения, отправленные в период простоя, могли быть доставлены с задержкой или частично потеряны — зависит от политики ретраев Telegram (не гарантирует бесконечные ретраи). Требует верификации |
| Ежемесячные платежи | **Не затронуты** | `process-recurring-payments` запускается по расписанию Celery Beat |
| Celery задачи | **Минимальный риск** | Redis настроен с RDB-персистентностью (`save 3600 1 300 100 60 10000`) и Docker volume. Данные сохраняются при рестарте. Однако AOF отключён (`appendonly no`), поэтому задачи, добавленные в очередь в последние секунды перед крашем (до ~60 сек), теоретически могли быть потеряны |

---

## Корневые причины

1. **Аппаратный сбой ноды хостера** — вне нашего контроля
2. **DNS-резолвер хостера восстанавливается медленно** — контейнеры используют DNS хостера по умолчанию
3. **Необработанное исключение в `set_bot_commands()`** — функция `bot/utils/commands.py:set_bot_commands()` вызывает `bot.set_my_commands()` без try/except. При недоступности DNS это приводит к аварийному завершению процесса бота
4. **Нет fallback на статические DNS** — контейнеры полностью зависят от DNS-резолвера ноды

---

## Рекомендации по минимизации времени простоя

### Приоритет 1: Быстрые улучшения (минуты работы)

#### 1.1. Статические DNS в docker-compose.yml

**Проблема:** Контейнеры используют DNS хостера, который после сбоя восстанавливается медленно.

**Решение:** Добавить Google и Cloudflare DNS во все сервисы, которым нужен внешний DNS:

```yaml
services:
  bot:
    dns:
      - 8.8.8.8
      - 1.1.1.1
    # ... остальные настройки

  celery:
    dns:
      - 8.8.8.8
      - 1.1.1.1

  celery-beat:
    dns:
      - 8.8.8.8
      - 1.1.1.1

  web:
    dns:
      - 8.8.8.8
      - 1.1.1.1
```

**Важно — проверка service discovery:**
Docker использует встроенный DNS-сервер (127.0.0.11) для резолвинга имён контейнеров (`db`, `redis`). Параметр `dns:` задаёт **внешние** DNS-серверы как fallback — Docker embedded DNS по-прежнему будет резолвить внутренние имена. Однако после применения необходимо обязательно проверить:
```bash
# Из контейнера бота проверить внутренние имена:
docker exec expense_bot_app nslookup db
docker exec expense_bot_app nslookup redis

# И внешние:
docker exec expense_bot_app nslookup api.telegram.org
```

**Ожидаемый эффект:** Сокращение фазы 2 с ~45 минут до ~0 минут для проблем с внешним DNS.

**Трудозатраты:** 5 минут (конфиг) + 5 минут (проверка)

#### 1.2. Уменьшить healthcheck interval для db и redis

**Текущее:** `interval: 120s` — Docker проверяет здоровье БД раз в 2 минуты. Контейнеры bot/celery ждут `service_healthy`, что может занять до 2+ минут.

**Рекомендация:**
```yaml
  db:
    healthcheck:
      interval: 10s     # Было 120s
      timeout: 5s       # Без изменений
      retries: 5        # Было 3 → увеличить, чтобы избежать флаппинга при тяжёлых рестартах
      start_period: 15s # Было 30s

  redis:
    healthcheck:
      interval: 10s     # Было 120s
      timeout: 3s       # Без изменений
      retries: 5        # Было 3 → увеличить
      start_period: 10s # Было 20s
```

**Примечание:** `retries` увеличен с 3 до 5 чтобы компенсировать более частые проверки. При interval=10s и retries=3 контейнер будет помечен unhealthy через 30 секунд — это может вызвать флаппинг при тяжёлых рестартах (когда БД долго поднимается). С retries=5 порог — 50 секунд, что даёт больше запаса.

**Ожидаемый эффект:** Зависимые контейнеры (bot, celery) стартуют на ~2 минуты быстрее.

**Трудозатраты:** 2 минуты (конфиг)

### Приоритет 2: Устойчивый запуск бота (30-60 минут работы)

#### 2.1. Обернуть set_bot_commands() в try/except

**Корневая причина крашей.** Минимальный фикс:

**Файл:** `bot/utils/commands.py`, функция `set_bot_commands()`

Добавить try/except вокруг `bot.set_my_commands()` (строка 21), аналогично тому как это уже сделано в `update_user_commands()` (строки 62-68 того же файла).

**Трудозатраты:** 5 минут

#### 2.2. Устойчивый on_startup с retry

Все Telegram API вызовы в `on_startup()` должны быть обёрнуты в try/except и/или выполняться в фоновой задаче. Стартап бота не должен зависеть от доступности внешних API.

**Файл:** `bot/main.py`, функция `on_startup()`

**Трудозатраты:** 15-20 минут

#### 2.3. Webhook setup в фоне (опционально, менее критично)

**Текущее поведение:**
```
Старт → set_webhook() [пойман] → on_startup/set_bot_commands [НЕ пойман] → CRASH
```

**Рекомендуемое поведение:**
```
Старт → запустить веб-сервер → set_webhook() + set_bot_commands() в фоне с retry
  ↓ (webhook не установлен)                    ↓ (фон: retry через 3s, 10s, 30s, 60s...)
  ↓ Веб-сервер принимает входящие запросы      ↓ Webhook установлен
  ↓ (Telegram может помнить старый URL)        ↓ Лог: "Webhook установлен"
```

**Ключевое улучшение:** Веб-сервер запускается СРАЗУ. Если Telegram всё ещё помнит старый webhook URL — бот начнёт обрабатывать запросы немедленно.

**Файл для изменения:** `bot/main.py`, функция `main_webhook()`

**Трудозатраты:** 30-60 минут

#### 2.4. Graceful обработка DNS ошибок в entrypoint

**Текущее:** `docker-entrypoint.sh` ждёт PostgreSQL и Redis (внутренние сервисы), но не проверяет внешний DNS.

**Рекомендация:** Добавить информационную проверку DNS (НЕ блокирующую):
```bash
# Проверка внешнего DNS (информационная, не блокирующая)
echo "Checking external DNS resolution..."
if nslookup api.telegram.org > /dev/null 2>&1; then
    echo "External DNS is ready!"
else
    echo "WARNING: External DNS not available yet, bot will retry Telegram API calls"
fi
```

### Приоритет 3: Инфраструктурная устойчивость

#### 3.1. Автоматическая активация BACKUP сервера

**Текущее:** Резервный сервер (72.56.67.202) настроен и готов, но активация ручная (смена IP на DuckDNS).

**Рекомендация:** Настроить мониторинг + автоматический failover:
1. Внешний health check (UptimeRobot, Healthchecks.io) пингует `https://expensebot.duckdns.org/webhook/`
2. При недоступности > 5 минут — уведомление на Telegram/email
3. Возможно: скрипт автоматической смены DNS на DuckDNS через API

**DuckDNS API для автопереключения:**
```bash
# Переключить на backup сервер:
curl "https://www.duckdns.org/update?domains=expensebot&token=YOUR_TOKEN&ip=72.56.67.202"

# Вернуть на primary:
curl "https://www.duckdns.org/update?domains=expensebot&token=YOUR_TOKEN&ip=176.124.218.53"
```

**Трудозатраты:** 2-4 часа (настройка мониторинга + скрипт failover)

#### 3.2. Telegram-уведомление админу при сбое

Отправлять сообщение админу (881292737) когда:
- Бот не может установить webhook 3+ раз подряд
- Бот восстановился после сбоя (с временем простоя)

---

## Сводная таблица: Эффект от улучшений

| Улучшение | Сокращение простоя | Трудозатраты | Приоритет |
|-----------|-------------------|--------------|-----------|
| Статические DNS | ~45 мин → ~0 мин (внешний DNS) | 10 мин | **P1** |
| Healthcheck interval + retries | ~2 мин → ~20 сек | 2 мин | **P1** |
| try/except в set_bot_commands | Устраняет краш-луп | 5 мин | **P2 (критично)** |
| Устойчивый on_startup | Бот не падает при DNS ошибках | 15-20 мин | **P2** |
| Webhook setup в фоне | Бот работает сразу после запуска | 30-60 мин | **P2** |
| DNS check в entrypoint | Информационное | 10 мин | **P2** |
| Авто-failover на BACKUP | Простой → 5 мин (TTL DNS) | 2-4 часа | **P3** |
| Уведомление админу | Быстрое реагирование | 1 час | **P3** |

### При реализации P1 + P2:
```
Текущий сценарий:   Сбой → сервер поднялся → DNS не работает → set_bot_commands краш →
                    48 перезапусков за 45 мин → DNS поднялся → бот работает

После улучшений:    Сбой → сервер поднялся → DNS через 8.8.8.8 (мгновенно) →
                    set_bot_commands в try/except (не крашит) → бот работает СРАЗУ
```

**Ожидаемое сокращение фазы 2: с 45 минут до 0-2 минут.**

---

## Текущая конфигурация (для справки)

### docker-compose.yml (ключевые параметры)
- **restart policy:** `unless-stopped` (все контейнеры) — ОК
- **depends_on:** bot/celery зависят от db (healthy) и redis (healthy) — ОК
- **healthcheck db:** interval=120s, retries=3, start_period=30s — СЛИШКОМ ДОЛГО
- **healthcheck redis:** interval=120s, retries=3, start_period=20s — СЛИШКОМ ДОЛГО
- **DNS:** не указан (используется DNS хостера) — ПРОБЛЕМА

### bot/main.py — main_webhook() (текущая логика)
1. Создаёт aiohttp app и регистрирует webhook handler
2. Пытается `bot.set_webhook()` — **обёрнуто в try/except** (строки 286-295) — ОК
3. Запускает `runner.setup()` → триггерит `on_startup()` → **set_bot_commands() БЕЗ try/except** — ПРОБЛЕМА
4. При успехе — запускает `web.TCPSite` на порту 8000

### bot/utils/commands.py — set_bot_commands()
- Вызывает `bot.set_my_commands()` (строка 21) — **БЕЗ try/except**
- При DNS ошибке — необработанное исключение → крах процесса
- Примечание: `update_user_commands()` в том же файле (строки 62-68) уже обёрнута в try/except

### Redis конфигурация
- **RDB persistence:** ВКЛЮЧЁН (`save 3600 1 300 100 60 10000`)
- **AOF persistence:** ВЫКЛЮЧЕН (`appendonly no`)
- **Docker volume:** Есть (данные переживают рестарт контейнера)
- **Вывод:** Большинство данных сохраняется, но задачи добавленные в последние ~60 сек перед крашем теоретически могут быть потеряны

### docker-entrypoint.sh
1. Ждёт PostgreSQL (pg_isready)
2. Ждёт Redis (sleep 5)
3. Выполняет миграции Django
4. Собирает статические файлы
5. Запускает основную команду (exec "$@")

---

## Логи инцидента (выдержки)

### Последний запрос до падения (14:37:13)
```
INFO 2026-02-07 14:37:13 logging_middleware Request: {"user_id": 348740371, "message_type": "text", "text_length": 12}
INFO 2026-02-07 14:37:13 expense Starting parse_expense_message for text: '40 транспорт'
INFO 2026-02-07 14:37:13 expense Created expense 1840 for user 348740371
```

### Цикл краш-рестарт после перезагрузки (15:16 – 16:01)
```
INFO  2026-02-07 15:16:49 main FSM storage: Redis с TTL=4 часа
ERROR 2026-02-07 15:17:05 main ❌ Ошибка установки webhook: ClientConnectorDNSError:
      Cannot connect to host api.telegram.org:443 ssl:default [Temporary failure in name resolution]
WARN  2026-02-07 15:17:05 main ⚠️ Бот продолжит работу, но webhook может не работать
ERROR 2026-02-07 15:17:21 base_events Unclosed client session
      client_session: <aiohttp.client.ClientSession object at 0x726258d8d550>
Starting Expense Bot container...          ← КОНТЕЙНЕР ПЕРЕЗАПУЩЕН
Waiting for PostgreSQL...
db:5432 - accepting connections
PostgreSQL is ready!
# ... повторяется 48 раз с интервалом ~48 секунд ...
```

### Успешный запуск (16:01:16)
```
INFO 2026-02-07 16:01:16 main Preloaded expense and income modules with Celery tasks
INFO 2026-02-07 16:01:16 main Бот запущен и готов к работе
INFO 2026-02-07 16:01:16 main Webhook сервер запущен на порту 8000
```

### Первый запрос после восстановления (16:01:27)
```
INFO 2026-02-07 16:01:27 logging_middleware Request: {"user_id": 348740371, "message_type": "text", "text_length": 10}
INFO 2026-02-07 16:01:27 expense Created expense 1841 for user 348740371
```

---

## Ревизия документа

| Версия | Дата | Изменения |
|--------|------|-----------|
| 1.0 | 07.02.2026 | Первоначальный отчёт |
| 1.1 | 07.02.2026 | Уточнена корневая причина фазы 2: `set_bot_commands()` без try/except, а не `set_webhook()`. Уточнены формулировки: потеря webhook-сообщений как "возможная задержка/частичная потеря". Добавлены детали Redis persistence. Добавлено предупреждение о проверке service discovery при смене DNS. Увеличен retries в healthcheck для защиты от флаппинга |
