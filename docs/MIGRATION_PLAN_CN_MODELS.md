# План миграции и внедрения китайских LLM (DeepSeek V3 и Qwen 2.5)

Этот документ описывает архитектурный план по внедрению поддержки моделей DeepSeek и Qwen (Alibaba Cloud) в проект `expense_bot`. 

**Цель:** Обеспечить работу бота на серверах в РФ без использования VPN, снизить затраты на AI и устранить зависимость от Google/OpenAI, сохранив при этом текущую функциональность как резервную.

---

## 1. Текущая архитектура (Как это работает сейчас)

В данный момент система использует паттерн "Селектор":

1.  **`AISelector` (`bot/services/ai_selector.py`)**: Определяет, какой сервис использовать (Google или OpenAI) на основе переменных окружения.
2.  **`GoogleAIService`**: Основной рабочий сервис. Использует библиотеку `google-generativeai`. Имеет сложную логику для Windows (multiprocessing).
3.  **`OpenAIService`**: Резервный сервис. Использует библиотеку `openai`. Реализует "эмуляцию" вызова функций через двухэтапный промптинг (сначала "выбери функцию", потом "выполни").

**Проблема:** Чтобы добавить DeepSeek и Qwen, нам не нужно писать 3-й и 4-й отдельные сервисы. Обе эти модели имеют API, полностью совместимое с форматом OpenAI.

---

## 2. Предлагаемая архитектура (Unified approach)

Вместо создания кучи дублирующих классов (`DeepSeekService`, `QwenService`), мы создадим **один универсальный сервис**, который умеет переключаться между провайдерами, просто меняя `base_url` и ключи API.

### Новые компоненты:

1.  **`UnifiedAIService` (Универсальный сервис)**:
    *   Заменит (или расширит) текущий `OpenAIService`.
    *   При инициализации принимает конфигурацию провайдера:
        *   `api_key`: Ключ API (с поддержкой ротации).
        *   `base_url`: Адрес сервера (например, `https://api.deepseek.com` для DeepSeek).
        *   `model_name`: Имя модели (например, `deepseek-chat` или `qwen-plus`).
    *   Использует стандартный клиент `openai`.

2.  **Расширенная ротация ключей (`KeyRotationMixin`)**:
    *   Добавим классы `DeepSeekKeyRotationMixin` и `QwenKeyRotationMixin` для управления пулами ключей новых провайдеров.

3.  **Обновленный `AISelector`**:
    *   Научится понимать типы провайдеров `deepseek` и `qwen`.
    *   Будет инстанцировать `UnifiedAIService` с правильными настройками URL и ключей.

---

## 3. Детальный план реализации

### Шаг 1: Подготовка конфигурации (.env и settings)
Необходимо добавить поддержку новых переменных окружения для хранения ключей.

**Что добавить в `.env`:**
```env
# DeepSeek
DEEPSEEK_API_KEY=sk-......
AI_PROVIDER_DEFAULT=deepseek  # Для переключения всего бота на DeepSeek

# Qwen (DashScope)
DASHSCOPE_API_KEY=sk-......
```

### Шаг 2: Обновление `KeyRotationMixin`
Файл: `bot/services/key_rotation_mixin.py`

Нужно создать два новых класса-миксина, которые будут работать аналогично `OpenAIKeyRotationMixin`, но забирать ключи из новых переменных (`DEEPSEEK_API_KEYS`, `DASHSCOPE_API_KEYS`).
*Важно:* У каждого миксина будет свое независимое состояние (счетчик ротации и список "мертвых" ключей), чтобы отказ DeepSeek не влиял на работу Qwen.

### Шаг 3: Создание `UnifiedAIService`
Файл: `bot/services/unified_ai_service.py` (Новый файл)

Это самый важный этап. Класс будет наследовать логику `OpenAIService`, но конструктор станет гибким:

```python
class UnifiedAIService(AIBaseService):
    def __init__(self, provider_name='openai'):
        # 1. Определяем настройки на основе провайдера
        if provider_name == 'deepseek':
            self.base_url = "https://api.deepseek.com"
            self.api_key_mixin = DeepSeekKeyRotationMixin
        elif provider_name == 'qwen':
            self.base_url = "https://dashscope-intl.aliyuncs.com/compatible-mode/v1"
            self.api_key_mixin = QwenKeyRotationMixin
        # ...
```

**Ключевые особенности реализации:**
*   **Function Calling:** Мы сохраним текущую логику OpenAI-сервиса (сначала запрос "выбери функцию", потом выполнение), так как она наиболее стабильна и универсальна для всех моделей. Нативные `tools` в DeepSeek работают хорошо, но Qwen может требовать специфики. Текстовый подход через `FUNCTION_CALL: name(args)` работает везде.
*   **Ротация:** Клиент `openai.OpenAI` будет пересоздаваться или обновляться при смене ключа.

### Шаг 4: Интеграция в `AISelector`
Файл: `bot/services/ai_selector.py`

Обновим метод `__new__` и `get_provider_settings`:

1.  Добавим блоки `elif provider_type == 'deepseek':` и `elif provider_type == 'qwen':`.
2.  В этих блоках будем возвращать экземпляр `UnifiedAIService(provider=...)`.
3.  Это позволит вам в любой момент сменить `AI_PROVIDER_DEFAULT=google` на `AI_PROVIDER_DEFAULT=deepseek` в `.env`, и бот мгновенно "переедет" на китайские сервера без остановки.

---

## 4. Экономическое обоснование и выбор моделей

В коде мы зафиксируем следующие рекомендуемые модели по умолчанию:

1.  **DeepSeek (Основной для РФ):**
    *   Модель: `deepseek-chat` (V3)
    *   Цена: ~$0.14 / 1M токенов (вход).
    *   Качество: Уровень GPT-4. Отлично пишет JSON.

2.  **Qwen (Резерв для РФ):**
    *   Модель: `qwen-plus`
    *   Цена: ~$0.40 / 1M токенов (вход).
    *   Качество: Очень высокое, стабильный аптайм (Alibaba Cloud).

---

## 5. Почему это безопасно?

1.  **Нет удаления старого:** Код Google (Gemini) и оригинальный OpenAI остаются нетронутыми. Если новые сервисы не заработают, вы просто не меняете переменную в `.env`.
2.  **Изоляция:** Новые миксины ротации ключей изолированы. Ошибка в ключе Qwen не сломает DeepSeek.
3.  **Быстрый откат:** Переключение обратно на Gemini занимает 1 секунду (правка .env и перезапуск контейнера/скрипта).
